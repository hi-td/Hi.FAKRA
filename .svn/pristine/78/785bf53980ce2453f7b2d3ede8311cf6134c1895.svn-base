using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using HalconDotNet;
using System.Windows.Forms;
using System.Drawing;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;

namespace VisionPlatform
{
    class Function
    {
        public static HWindow m_hWnd = null;
        public static HObject m_hImage = null;

        public static int imageWidth;
        public static int imageHeight;

        public static ShowParam m_showParam = new ShowParam();

        public static Line m_line = new Line();
        public static Circle m_circle = new Circle();
        public static Rect1 m_rect1 = new Rect1();
        public static Rect2 m_rect2 = new Rect2();
        public static Ellipse m_ellipse = new Ellipse();

        private static HObject m_ObjShow = new HObject();
        private static int m_nLastDraw = -1;
        public enum lastDraw
        {
            line,
            rect1,
            rect2,
            circle,
            ellipse
        }
        private static int lastDrawObj(lastDraw last)
        {
            
            switch (last)
            {
                case lastDraw.line:
                    return 0;
                case lastDraw.rect1:
                    return 1;
                case lastDraw.rect2:
                    return 2;
                case lastDraw.circle:
                    return 3;
                case lastDraw.ellipse:
                    return 4;
                default:
                    return -1;
            }
        }

        #region 工具函数

        //显示设置:设置显示的颜色、线条粗细等
        public static void SetShow(ShowParam param)
        {
            try
            {
                m_showParam = param;
                m_hWnd.SetDraw(param.draw);
                m_hWnd.SetLineWidth(param.lineWidth);
                m_hWnd.SetColor(param.color);
            }
            catch(HalconException ex)
            {
                return;
            }
        }
        private static void scale_image_range(HObject ho_Image, out HObject ho_ImageScaled, HTuple hv_Min, HTuple hv_Max)
        {
            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_SelectedChannel = null, ho_LowerRegion = null;
            HObject ho_UpperRegion = null;

            // Local copy input parameter variables 
            HObject ho_Image_COPY_INP_TMP;
            ho_Image_COPY_INP_TMP = ho_Image.CopyObj(1, -1);

            // Local control variables 

            HTuple hv_LowerLimit = new HTuple(), hv_UpperLimit = new HTuple();
            HTuple hv_Mult = null, hv_Add = null, hv_Channels = null;
            HTuple hv_Index = null, hv_MinGray = new HTuple(), hv_MaxGray = new HTuple();
            HTuple hv_Range = new HTuple();
            HTuple hv_Max_COPY_INP_TMP = hv_Max.Clone();
            HTuple hv_Min_COPY_INP_TMP = hv_Min.Clone();

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageScaled);
            HOperatorSet.GenEmptyObj(out ho_SelectedChannel);
            HOperatorSet.GenEmptyObj(out ho_LowerRegion);
            HOperatorSet.GenEmptyObj(out ho_UpperRegion);
            //Convenience procedure to scale the gray values of the
            //input image Image from the interval [Min,Max]
            //to the interval [0,255] (default).
            //Gray values < 0 or > 255 (after scaling) are clipped.
            //
            //If the image shall be scaled to an interval different from [0,255],
            //this can be achieved by passing tuples with 2 values [From, To]
            //as Min and Max.
            //Example:
            //scale_image_range(Image:ImageScaled:[100,50],[200,250])
            //maps the gray values of Image from the interval [100,200] to [50,250].
            //All other gray values will be clipped.
            //
            //input parameters:
            //Image: the input image
            //Min: the minimum gray value which will be mapped to 0
            //     If a tuple with two values is given, the first value will
            //     be mapped to the second value.
            //Max: The maximum gray value which will be mapped to 255
            //     If a tuple with two values is given, the first value will
            //     be mapped to the second value.
            //
            //output parameter:
            //ImageScale: the resulting scaled image
            //
            if (hv_Min_COPY_INP_TMP.TupleLength() == 2)
            {
                hv_LowerLimit = hv_Min_COPY_INP_TMP[1];
                hv_Min_COPY_INP_TMP = hv_Min_COPY_INP_TMP[0];
            }
            else
            {
                hv_LowerLimit = 0.0;
            }
            if (hv_Max_COPY_INP_TMP.TupleLength() == 2)
            {
                hv_UpperLimit = hv_Max_COPY_INP_TMP[1];
                hv_Max_COPY_INP_TMP = hv_Max_COPY_INP_TMP[0];
            }
            else
            {
                hv_UpperLimit = 255.0;
            }
            //
            //Calculate scaling parameters
            hv_Mult = (((hv_UpperLimit - hv_LowerLimit)).TupleReal()) / (hv_Max_COPY_INP_TMP - hv_Min_COPY_INP_TMP);
            hv_Add = ((-hv_Mult) * hv_Min_COPY_INP_TMP) + hv_LowerLimit;
            //
            //Scale image
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ScaleImage(ho_Image_COPY_INP_TMP, out ExpTmpOutVar_0, hv_Mult, hv_Add);
                ho_Image_COPY_INP_TMP.Dispose();
                ho_Image_COPY_INP_TMP = ExpTmpOutVar_0;
            }
            //
            //Clip gray values if necessary
            //This must be done for each channel separately
            HOperatorSet.CountChannels(ho_Image_COPY_INP_TMP, out hv_Channels);
            HTuple end_val48 = hv_Channels;
            HTuple step_val48 = 1;
            for (hv_Index = 1; hv_Index.Continue(end_val48, step_val48); hv_Index = hv_Index.TupleAdd(step_val48))
            {
                ho_SelectedChannel.Dispose();
                HOperatorSet.AccessChannel(ho_Image_COPY_INP_TMP, out ho_SelectedChannel, hv_Index);
                HOperatorSet.MinMaxGray(ho_SelectedChannel, ho_SelectedChannel, 0, out hv_MinGray, out hv_MaxGray, out hv_Range);
                ho_LowerRegion.Dispose();
                HOperatorSet.Threshold(ho_SelectedChannel, out ho_LowerRegion, ((hv_MinGray.TupleConcat(hv_LowerLimit))).TupleMin(), hv_LowerLimit);
                ho_UpperRegion.Dispose();
                HOperatorSet.Threshold(ho_SelectedChannel, out ho_UpperRegion, hv_UpperLimit,
                    ((hv_UpperLimit.TupleConcat(hv_MaxGray))).TupleMax());
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.PaintRegion(ho_LowerRegion, ho_SelectedChannel, out ExpTmpOutVar_0, hv_LowerLimit, "fill");
                    ho_SelectedChannel.Dispose();
                    ho_SelectedChannel = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.PaintRegion(ho_UpperRegion, ho_SelectedChannel, out ExpTmpOutVar_0, hv_UpperLimit, "fill");
                    ho_SelectedChannel.Dispose();
                    ho_SelectedChannel = ExpTmpOutVar_0;
                }
                if ((int)(new HTuple(hv_Index.TupleEqual(1))) != 0)
                {
                    ho_ImageScaled.Dispose();
                    HOperatorSet.CopyObj(ho_SelectedChannel, out ho_ImageScaled, 1, 1);
                }
                else
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.AppendChannel(ho_ImageScaled, ho_SelectedChannel, out ExpTmpOutVar_0);
                        ho_ImageScaled.Dispose();
                        ho_ImageScaled = ExpTmpOutVar_0;
                    }
                }
            }
            ho_Image_COPY_INP_TMP.Dispose();
            ho_SelectedChannel.Dispose();
            ho_LowerRegion.Dispose();
            ho_UpperRegion.Dispose();

            return;
        }

        //获取WindowControl的句柄
        public static void GetHalconWnd(HWindowControl hWndCtrl)
        {
            m_hWnd = hWndCtrl.HalconWindow;
        }

        //获取鼠标按下时的图像坐标
        public static Point GetMousePos()
        {
            Point point = new Point();
            int row, col, button;
            try
            {
                m_hWnd.GetMposition(out row, out col, out button);
                point.X = col;
                point.Y = row;
                return point;
            }
            catch(HalconException ex)
            {
                MessageBox.Show(ex.ToString());
                return point;
            }
           

        }
        //画矩形1
        public static Rect1 DrawRect1()
        {
            Rect1 rect1 = new Rect1();

            HObject ho_Rect1 = null;
            HOperatorSet.GenEmptyObj(out ho_Rect1);

            HTuple hRectRow1 = new HTuple(), hRectCol1 = new HTuple(), hRectRow2 = new HTuple(), hRectCol2 = new HTuple();

            try
            {
                if (null == m_hWnd || null == m_hImage) return rect1;
                m_hWnd.DispObj(m_hImage);
                HOperatorSet.DrawRectangle1(m_hWnd, out hRectRow1, out hRectCol1, out hRectRow2, out hRectCol2);
                HOperatorSet.GenRectangle1(out ho_Rect1, hRectRow1, hRectCol1, hRectRow2, hRectCol2);
                m_hWnd.DispObj(ho_Rect1);
                if (0 != ho_Rect1.CountObj())
                {
                    rect1.dRectRow1 = hRectRow1.D;
                    rect1.dRectCol1 = hRectCol1.D;
                    rect1.dRectRow2 = hRectRow2.D;
                    rect1.dRectCol2 = hRectCol2.D;
                }
                m_nLastDraw = lastDrawObj(lastDraw.rect1);
                return rect1;
            }
            catch (HalconException ex)
            {
                MessageBox.Show(ex.ToString());
                return rect1;
            }
            finally
            {
                if (null != ho_Rect1) ho_Rect1.Dispose();
            }
        }
        //画矩形2
        public static Rect2 DrawRect2()
        {
            Rect2 rect2 = new Rect2();
            HObject ho_Rect2 = null;
            HOperatorSet.GenEmptyObj(out ho_Rect2);

            HTuple hRect2Row = new HTuple(), hRect2Col = new HTuple(), hPhi = new HTuple(), hLength1 = new HTuple(), hLength2 = new HTuple();

            try
            {
                if (null == m_hImage || null == m_hWnd) return rect2;
                m_hWnd.DispObj(m_hImage);
                HOperatorSet.DrawRectangle2(m_hWnd, out hRect2Row, out hRect2Col, out hPhi, out hLength1, out hLength2);
                HOperatorSet.GenRectangle2(out ho_Rect2, hRect2Row, hRect2Col, hPhi, hLength1, hLength2);
                m_hWnd.DispObj(ho_Rect2);
                if (0 != ho_Rect2.CountObj())
                {
                    rect2.dRect2Row = hRect2Row.D;
                    rect2.dRect2Col = hRect2Col.D;
                    rect2.dPhi = hPhi.D;
                    rect2.dLength1 = hLength1.D;
                    rect2.dLength2 = hLength2.D;
                }
                m_nLastDraw = lastDrawObj(lastDraw.rect2);
                return rect2;
            }
            catch (HalconException ex)
            {
                MessageBox.Show(ex.ToString());
                rect2.dRect2Row = 0;
                rect2.dRect2Col = 0;
                rect2.dPhi = 0;
                rect2.dLength1 = 0;
                rect2.dLength2 = 0;
                return rect2;
            }
            finally
            {
                if (null != ho_Rect2) ho_Rect2.Dispose();
            }
        }
        //画圆形
        public static Circle DrawCircle()
        {
            Circle circle = new Circle();

            HObject ho_Circle = null;
            HOperatorSet.GenEmptyObj(out ho_Circle);

            HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_Radius = new HTuple();

            try
            {
                if (null == m_hImage || null == m_hWnd) return circle;
                m_hWnd.DispObj(m_hImage);
                HOperatorSet.DrawCircle(m_hWnd, out hv_Row, out hv_Col, out hv_Radius);
                HOperatorSet.GenCircle(out ho_Circle, hv_Row, hv_Col, hv_Radius);
                m_hWnd.DispObj(ho_Circle);
                if (0 != ho_Circle.CountObj())
                {
                    circle.dRow = hv_Row.D;
                    circle.dCol = hv_Col.D;
                    circle.dRadius = hv_Radius.D;
                }
                m_nLastDraw = lastDrawObj(lastDraw.circle);
                return circle;
            }
            catch (HalconException ex)
            {
                MessageBox.Show(ex.ToString());
                return circle;
            }
            finally
            {
                if (null != ho_Circle) ho_Circle.Dispose();
            }
        }
        //画直线
        private static void gen_arrow_contour_xld(out HObject ho_Arrow, HTuple hv_Row1, HTuple hv_Column1, HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth)
        {
            HObject ho_TempArrow = null;

            HTuple hv_Length = null, hv_ZeroLengthIndices = null;
            HTuple hv_DR = null, hv_DC = null, hv_HalfHeadWidth = null;
            HTuple hv_RowP1 = null, hv_ColP1 = null, hv_RowP2 = null;
            HTuple hv_ColP2 = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Arrow);
            HOperatorSet.GenEmptyObj(out ho_TempArrow);

            ho_Arrow.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Arrow);

            HOperatorSet.DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_Length);
            //
            //Mark arrows with identical start and end point
            //(set Length to -1 to avoid division-by-zero exception)
            hv_ZeroLengthIndices = hv_Length.TupleFind(0);
            if (-1 != hv_ZeroLengthIndices[0])
            {
                if (hv_Length == null)
                    hv_Length = new HTuple();
                hv_Length[hv_ZeroLengthIndices] = -1;
            }
            //
            //Calculate auxiliary variables.
            hv_DR = (1.0 * (hv_Row2 - hv_Row1)) / hv_Length;
            hv_DC = (1.0 * (hv_Column2 - hv_Column1)) / hv_Length;
            hv_HalfHeadWidth = hv_HeadWidth / 2.0;
            //
            //Calculate end points of the arrow head.
            hv_RowP1 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) + (hv_HalfHeadWidth * hv_DC);
            hv_ColP1 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) - (hv_HalfHeadWidth * hv_DR);
            hv_RowP2 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) - (hv_HalfHeadWidth * hv_DC);
            hv_ColP2 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) + (hv_HalfHeadWidth * hv_DR);
            //
            //Finally create output XLD contour for each input point pair
            for (int i = 0; i <= (hv_Length.TupleLength() - 1); i++)
            {
                if (-1 == hv_Length[i].D)
                {
                    //Create_ single points for arrows with identical start and end point
                    ho_TempArrow.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_TempArrow, hv_Row1[i], hv_Column1[i]);
                }
                else
                {
                    //Create arrow contour
                    ho_TempArrow.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_TempArrow, new HTuple(hv_RowP1[i].D).TupleConcat(hv_Row2[i].D).TupleConcat(hv_RowP2[i].D).TupleConcat(hv_RowP1[i].D),
                        new HTuple(hv_ColP1[i].D).TupleConcat(hv_Column2[i].D).TupleConcat(hv_ColP2[i].D).TupleConcat(hv_ColP1[i].D));
                    HOperatorSet.GenRegionContourXld(ho_TempArrow, out ho_TempArrow, "filled");
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Arrow, ho_TempArrow, out ExpTmpOutVar_0);
                    ho_Arrow.Dispose();
                    ho_Arrow = ExpTmpOutVar_0;
                }
            }
            ho_TempArrow.Dispose();
            return;
        }
        public static Line DrawLine()
        {
            Line line = new Line();

            HObject ho_Line = null, ho_Arrow = null;
            HOperatorSet.GenEmptyObj(out ho_Line);
            HOperatorSet.GenEmptyObj(out ho_Arrow);

            HTuple hv_StartRow = new HTuple(), hv_StartCol = new HTuple();
            HTuple hv_EndRow = new HTuple(), hv_EndCol = new HTuple();

            try
            {
                if (null == m_hImage || null == m_hWnd) return line;
                m_hWnd.DispObj(m_hImage);
                HOperatorSet.DrawLine(m_hWnd, out hv_StartRow, out hv_StartCol, out hv_EndRow, out hv_EndCol);
                HTuple hv_midRow = (hv_StartRow + hv_EndRow) / 2.0;
                HTuple hv_midCol = (hv_EndCol + hv_StartCol) / 2.0;
                double dDist = Math.Sqrt(Math.Pow((hv_midRow - hv_StartRow), 2)+Math.Pow((hv_midCol - hv_StartCol), 2))/10;
                gen_arrow_contour_xld(out ho_Arrow, hv_StartRow, hv_StartCol, hv_midRow, hv_midCol, dDist, dDist * 1.5);
                HOperatorSet.GenRegionLine(out ho_Line, hv_StartRow, hv_StartCol, hv_EndRow, hv_EndCol);
                m_hWnd.DispObj(ho_Line);
                m_hWnd.SetColor("green");
               // m_hWnd.SetDraw("fill");
                m_hWnd.DispObj(ho_Arrow);
                SetShow(m_showParam);
                if (0 != ho_Line.CountObj())
                {
                    line.dStartRow = hv_StartRow.D;
                    line.dStartCol = hv_StartCol.D;
                    line.dEndRow = hv_EndRow.D;
                    line.dEndCol = hv_EndCol.D;
                }
                m_nLastDraw = lastDrawObj(lastDraw.line);
                return line;
            }
            catch (HalconException ex)
            {
                MessageBox.Show(ex.ToString());
                return line;
            }
            finally
            {
                if (null != ho_Line) ho_Line.Dispose();
            }
        }
        //绘制椭圆
        public static Ellipse DrawEllipse()
        {
            Ellipse ellipse = new Ellipse();

            HObject ho_Ellipse = null;
            HOperatorSet.GenEmptyObj(out ho_Ellipse);

            HTuple hv_row = new HTuple(), hv_column = new HTuple(), hv_phi = new HTuple(), hv_radius1 = new HTuple(), hv_radius2 = new HTuple();

            try
            {
                m_ObjShow.Dispose();
                if (null == m_hImage || null == m_hWnd) return ellipse;
                m_hWnd.DispObj(m_hImage);
                HOperatorSet.DrawEllipse(m_hWnd, out hv_row, out hv_column, out hv_phi, out hv_radius1, out hv_radius2);
                HOperatorSet.GenEllipse(out ho_Ellipse, hv_row, hv_column, hv_phi, hv_radius1, hv_radius2);
                m_hWnd.DispObj(ho_Ellipse);
                if (0 != ho_Ellipse.CountObj())
                {
                    ellipse.dRow = hv_row.D;
                    ellipse.dColumn = hv_column.D;
                    ellipse.dPhi = hv_phi.D;
                    ellipse.dRadius1 = hv_radius1.D;
                    ellipse.dRadius2 = hv_radius2.D;
                }
                m_nLastDraw = lastDrawObj(lastDraw.ellipse);
                return ellipse;
            }
            catch (HalconException ex)
            {
                MessageBox.Show(ex.ToString());
                ellipse.dRow = 0;
                ellipse.dColumn = 0;
                ellipse.dPhi = 0;
                ellipse.dRadius1 = 0;
                ellipse.dRadius2 = 0;
                return ellipse;
            }
            finally
            {
                if (null != ho_Ellipse) ho_Ellipse.Dispose();
            }
        }
        //显示十字线
        public static void ShowCross(double dRow0, double dCol0, double dRow1, double dCol1)
        {
            try
            {
                int row, col, button;
                m_hWnd.GetMposition(out row, out col, out button);
                ShowImages(dRow0, dCol0, dRow1, dCol1);
                m_hWnd.DispLine(row, 0, row, (double)imageWidth);
                m_hWnd.DispLine(0, col, (double)imageHeight, col);
            }
            catch (System.Exception ex)
            {
                return;
            }
            finally
            {
            }
        }
        //显示坐标和灰度值
        public static void ShowCoordinateGrayVal(out int nRow, out int nCol, out List<double> listGrayVal)
        {
            nRow = 0;
            nCol = 0;
            listGrayVal = new List<double>();
            HTuple hv_GrayVal = new HTuple(), hv_channels = new HTuple();

            try
            {
                int button;
                m_hWnd.GetMposition(out nRow, out nCol, out button);
                HOperatorSet.GetGrayval(m_hImage, nRow, nCol, out hv_GrayVal);
                for(int i=0;i<hv_GrayVal.TupleLength();i++)
                {
                    listGrayVal.Add(hv_GrayVal[i].D);
                }
            }
            catch(HalconException error)
            {
                return;
            }
        }
        //画点
        public static PointF DrawPoint()
        {
            PointF point = new PointF();

            HTuple hv_row = new HTuple(), hv_col = new HTuple(), hv_button = new HTuple();
            HObject ho_Cross = null;
            HOperatorSet.GenEmptyObj(out ho_Cross);
            try
            {
                m_hWnd.DispObj(m_hImage);
                HOperatorSet.GetMbuttonSubPix(m_hWnd, out hv_row, out hv_col, out hv_button);
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_row, hv_col, 60, 0);
                m_hWnd.DispObj(ho_Cross);
                point.Y = (float)hv_row.D;
                point.X = (float)hv_col.D;
                return point;
            }
            catch (HalconException error)
            {
                MessageBox.Show(error.ToString());
                return point;
            }
            finally
            {
                if (null != ho_Cross) ho_Cross.Dispose();
            }
        }

        //設置圖片顯示比例
        public static void FitImageToWindow(HWindowControl hWindowControlTemp, out double dReslutRow0, out double dReslutCol0, out double dReslutRow1, out double dReslutCol1)
        {
            HTuple m_hWidth = null, m_hHeight = null;
            dReslutRow0 = 0;
            dReslutCol0 = 0;
            dReslutRow1 = 0;
            dReslutCol1 = 0;

            try
            {
                if (m_hImage != null)
                {
                    HOperatorSet.GetImageSize(m_hImage, out m_hWidth, out m_hHeight);
                }
                double dRow0 = 0, dCol0 = 0, dRow1 = m_hHeight.D - 1, dCol1 = m_hWidth.D - 1;
                if (m_hHeight != null && m_hWidth != null)
                {
                    float fImage = (float)m_hWidth / (float)m_hHeight;
                    float fWindow = (float)hWindowControlTemp.Width / hWindowControlTemp.Height;

                    if (fWindow > fImage)
                    {
                        float w = fWindow * (float)m_hHeight;
                        dRow0 = 0;
                        dCol0 = -(w - m_hWidth) / 2;
                        dRow1 = m_hHeight - 1;
                        dCol1 = m_hWidth + (w - m_hWidth) / 2;
                    }
                    else
                    {
                        float h = (float)m_hWidth / fWindow;
                        dRow0 = -(h - m_hHeight) / 2;
                        dCol0 = 0;
                        dRow1 = m_hHeight + (h - m_hHeight) / 2;
                        dCol1 = m_hWidth.D - 1;
                    }
                }
                dReslutRow0 = dRow0;
                dReslutCol0 = dCol0;
                dReslutRow1 = dRow1;
                dReslutCol1 = dCol1;

                imageWidth = m_hWidth.I;
                imageHeight = m_hHeight.I;

                ShowImages(dReslutRow0, dReslutCol0, dReslutRow1, dReslutCol1);
            }
            catch (System.Exception ex)
            {
                return;
            }


        }

        //显示图片
        public static void ShowImages(double dRow0, double dCol0, double dRow1, double dCol1)
        {
            HObject ho_Circle = null;

            HOperatorSet.GenEmptyObj(out ho_Circle);
            try
            {
                if (null != m_hWnd)
                {
                    HOperatorSet.SetSystem("flush_graphic", "false");
                    HOperatorSet.ClearWindow(m_hWnd);
                    if (m_hImage != null)
                    {
                        HOperatorSet.SetPart(m_hWnd, dRow0, dCol0, dRow1 - 1, dCol1 - 1);
                        m_hWnd.DispObj(m_hImage);
                    }
                    ShowRegion();
                    HOperatorSet.SetSystem("flush_graphic", "true");
                    HObject emptyObject = null;
                    HOperatorSet.GenEmptyObj(out emptyObject);
                    m_hWnd.DispObj(emptyObject);
                }
            }
            catch (HalconException error)
            {
                
            }

        }

        //随图片放大缩小显示图形
        public static void ShowRegion()
        {

            try
            {
                switch(m_nLastDraw)
                {
                    case 0:
                        HOperatorSet.GenRegionLine(out m_ObjShow, m_line.dStartRow, m_line.dStartCol,m_line.dEndRow, m_line.dEndCol);
                        break;
                    case 1:
                        HOperatorSet.GenRectangle1(out m_ObjShow, m_rect1.dRectRow1, m_rect1.dRectCol1, m_rect1.dRectRow2, m_rect1.dRectCol2);
                        break;
                    case 2:
                        HOperatorSet.GenRectangle2(out m_ObjShow, m_rect2.dRect2Row, m_rect2.dRect2Col, m_rect2.dPhi, m_rect2.dLength1, m_rect2.dLength2);
                        break;
                    case 3:
                        HOperatorSet.GenCircle(out m_ObjShow, m_circle.dRow, m_circle.dCol, m_circle.dRadius);
                        break;
                    case 4:
                        HOperatorSet.GenEllipse(out m_ObjShow, m_ellipse.dRow, m_ellipse.dColumn, m_ellipse.dPhi, m_ellipse.dRadius1, m_ellipse.dRadius2);
                        break;
                    default:
                        break;
                }
                m_hWnd.DispObj(m_ObjShow);
            }
            catch(HalconException error)
            {

            }
        }
        public static bool LoadImageFromFile(string strFilePath, HWindowControl hWindowControlTemp,
                                             out double dReslutRow0, out double dReslutCol0, out double dReslutRow1, out double dReslutCol1)
        {
            dReslutRow0 = 0;
            dReslutCol0 = 0;
            dReslutRow1 = 0;
            dReslutCol1 = 0;

            try
            {
                HOperatorSet.ReadImage(out m_hImage, strFilePath);
                FitImageToWindow(hWindowControlTemp, out dReslutRow0, out dReslutCol0, out dReslutRow1, out dReslutCol1);
                ShowImages(dReslutRow0, dReslutCol0, dReslutRow1, dReslutCol1);
                return true;
            }
            catch (System.Exception ex)
            {
                return false;
            }

        }
        //縮放图片
        public static void ZoomImage(HWindowControl hWndCtrl, int zDelta, Point pt, ref double dRow0, ref double dCol0, ref double dRow1, ref double dCol1)
        {
            HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
            try
            {
                HOperatorSet.GetImageSize(m_hImage, out hv_Width, out hv_Height);
                if (m_hImage.IsInitialized())
                {
                    double ImagePtX, ImagePtY;
                    double Row0, Col0, Row1, Col1;
                    double Scale = 0.1;

                    ImagePtX = dCol0 + pt.X / (hWndCtrl.Width - 1.0) * (dCol1 - dCol0);
                    ImagePtY = dRow0 + pt.Y / (hWndCtrl.Height - 1.0) * (dRow1 - dRow0);

                    if (zDelta > 0)
                    {
                        Row0 = ImagePtY - 1 / (1 - Scale) * (ImagePtY - dRow0);
                        Row1 = ImagePtY - 1 / (1 - Scale) * (ImagePtY - dRow1);
                        Col0 = ImagePtX - 1 / (1 - Scale) * (ImagePtX - dCol0);
                        Col1 = ImagePtX - 1 / (1 - Scale) * (ImagePtX - dCol1);
                    }
                    else
                    {
                        Row0 = ImagePtY - 1 / (1 + Scale) * (ImagePtY - dRow0);
                        Row1 = ImagePtY - 1 / (1 + Scale) * (ImagePtY - dRow1);
                        Col0 = ImagePtX - 1 / (1 + Scale) * (ImagePtX - dCol0);
                        Col1 = ImagePtX - 1 / (1 + Scale) * (ImagePtX - dCol1);
                    }
                    dRow0 = Row0;
                    dCol0 = Col0;
                    dRow1 = Row1;
                    dCol1 = Col1;
                }
                ShowImages(dRow0, dCol0, dRow1, dCol1);

            }
            catch (System.Exception ex)
            {

            }
        }

        //平移图像   
        public static void MoveImage(Point pMouseDown, Point pMouseUp, HWindowControl hWndCtrl, ref double dRow0, ref double dCol0, ref double dRow1, ref double dCol1)
        {
            if (pMouseDown.X == 0 || pMouseDown.Y == 0) //像素坐标
                return;
            int row, col, button;
            try
            {
                m_hWnd.GetMposition(out row, out col, out button);

                double dbRowMove, dbColMove;
                dbRowMove = (pMouseDown.Y - pMouseUp.Y)*(dRow1 - dRow0)/ hWndCtrl.Height;//计算光标在X轴拖动的距离
                dbColMove = (pMouseDown.X - pMouseUp.X) * (dCol1 - dCol0) / hWndCtrl.Width;//计算光标在Y轴拖动的距离

                
                dRow0 = dRow0 + dbRowMove;
                dCol0 = dCol0 + dbColMove;
                dRow1 = dRow1 + dbRowMove;
                dCol1 = dCol1 + dbColMove;

                ShowImages(dRow0, dCol0, dRow1, dCol1);
            }
            catch (HalconException error)
            {
            }
        }
       
        //保存结果图片
        public static void SaveResultImage(string strFilePath)  //输入文件夹路径，不包含文件名字
        {
            try
            {
                if (string.IsNullOrWhiteSpace(strFilePath))
                    return;
                var folder = Path.GetDirectoryName(strFilePath);
                if (!Directory.Exists(folder))
                    Directory.CreateDirectory(folder);
                
                if("" != strFilePath)
                {
                  //  HOperatorSet.DumpWindow(m_hWnd, "bmp", strFilePath);
                    HOperatorSet.DumpWindow(m_hWnd, "jpeg", strFilePath);
                   
                }
            }
            catch(HalconException error)
            {
                MessageBox.Show(error.ToString());
                return;
            }
        }

        public static void SaveResultImageToByte(string strFilePath)
        {
            HTuple hv_Pointer = new HTuple(), hv_Type = new HTuple(), hv_Width = new HTuple(), hv_Height = new HTuple();


            HObject ho_image = null;

            HOperatorSet.GenEmptyObj(out ho_image);
            try
            {
                if ("" != strFilePath)
                {
                    HOperatorSet.DumpWindowImage(out ho_image, m_hWnd);
                    HOperatorSet.GetImagePointer1(ho_image, out hv_Pointer, out hv_Type, out hv_Width, out hv_Height);
                    unsafe
                    {
                        byte *p = (byte*)hv_Pointer[0].L;
                        int height = hv_Height.I;
                        int width = hv_Width.I;
                    }
                    

                }
            }
            catch (HalconException error)
            {
                MessageBox.Show(error.ToString());
                return;
            }
            catch(Exception error)
            {
                MessageBox.Show(error.ToString());
                return;
            }
        }

        //保存图片
        public static void SaveImage(string strSavePath)
        {
            try
            {
                if(null != m_hImage)
                {
                    HOperatorSet.WriteImage(m_hImage, "bmp", 0, strSavePath);
                }
                
            }
            catch(HalconException error)
            {
                MessageBox.Show(error.ToString());
                return;
            }

        }
            
        //基于区域创建模板
        public static bool CreateRegionModel(LocatInParams inPara, Circle circle, out LocatOutParams outData)
        {
            outData = new LocatOutParams();
            outData.dModelRow = 0;
            outData.dModelCol = 0;
            outData.dModelAngle = 0;
            HObject ho_Rectangle, ho_ImageReduced;

            HTuple hv_ModelID;
            HTuple  hv_Row, hv_Column, hv_Angle, hv_Score;

            if (0 == circle.dRadius) 
            {
                MessageBox.Show("请先选择圆形模板区域。");
                return false; 
            }
            try
            {
                //HOperatorSet.GenRectangle1(out ho_Rectangle, rect1.dRectRow1, rect1.dRectCol1, rect1.dRectRow2, rect1.dRectCol2);
                HOperatorSet.GenCircle(out ho_Rectangle, circle.dRow, circle.dCol, circle.dRadius);
                m_hWnd.DispObj(ho_Rectangle);
                HOperatorSet.ReduceDomain(m_hImage, ho_Rectangle, out ho_ImageReduced);
                HOperatorSet.CreateShapeModel(ho_ImageReduced, "auto", new HTuple(inPara.dAngleStart).TupleRad(), new HTuple(inPara.dAngleEnd).TupleRad(), 
			                                 "auto", "auto", "use_polarity", "auto", "auto",  out hv_ModelID);
                HOperatorSet.FindShapeModel(m_hImage, hv_ModelID, new HTuple(inPara.dAngleStart).TupleRad(), new HTuple(inPara.dAngleEnd).TupleRad(), 0.5, 1, 0.5,
			                                "least_squares", 0, 0.9, out hv_Row, out hv_Column, out hv_Angle, out hv_Score);
                if (0 == hv_Row.TupleLength())
                {
                    MessageBox.Show("模板创建失败！");
                    return false;
                }
                else
                {
			        HOperatorSet.DispCross(m_hWnd,hv_Row,hv_Column,20,hv_Angle);
			        outData.dModelRow = hv_Row.D;
			        outData.dModelCol = hv_Column.D;
			        outData.dModelAngle = hv_Angle.D;
                    outData.nModelID = hv_ModelID.I;
                    return true;
                }
            }
            catch (HalconException error)
            {
                MessageBox.Show(error.ToString());
                return false;
            }
        }
        //基于轮廓创建模板
        public static bool GetModelCont(LocatInParams inPara, Circle circle, int nThd)
        {
            HTuple hv_Area = new HTuple(), hv_AreaMax = new HTuple();

            HObject ho_ModelCont = null;
            HObject ho_Circle = null, ho_ImageReduced = null, ho_RegionSelect = null ;
            HObject ho_Region = null, ho_SelRegion = null, ho_RegClosing = null;
            
            HOperatorSet.GenEmptyObj(out ho_Circle);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            HOperatorSet.GenEmptyObj(out ho_Region);
            HOperatorSet.GenEmptyObj(out ho_SelRegion);
            HOperatorSet.GenEmptyObj(out ho_RegClosing);
            HOperatorSet.GenEmptyObj(out ho_ModelCont);
            try
            {
                //HOperatorSet.GenRectangle1(out ho_Rectangle, rect1.dRectRow1, rect1.dRectCol1, rect1.dRectRow2, rect1.dRectCol2);
                HOperatorSet.GenCircle(out ho_Circle, circle.dRow, circle.dCol, circle.dRadius);
                m_hWnd.DispObj(ho_Circle);
                HOperatorSet.ReduceDomain(m_hImage, ho_Circle, out ho_ImageReduced);
                HOperatorSet.Threshold(ho_ImageReduced, out ho_Region, nThd, 255);
                HOperatorSet.FillUp(ho_Region, out ho_Region);
                HOperatorSet.Connection(ho_Region, out ho_Region);
                HOperatorSet.SelectShapeStd(ho_Region, out ho_SelRegion, "max_area", 70);
                HOperatorSet.RegionFeatures(ho_Region, "area", out hv_Area);
                HOperatorSet.RegionFeatures(ho_SelRegion, "area", out hv_AreaMax);
                HOperatorSet.SelectShape(ho_Region, out ho_RegionSelect, "area", "and", hv_Area.TupleMean() * 2, hv_AreaMax + 20);
                HOperatorSet.Union1(ho_RegionSelect, out ho_RegionSelect);
                HOperatorSet.ClosingCircle(ho_RegionSelect, out ho_RegClosing, 5);
                HOperatorSet.GenContourRegionXld(ho_RegClosing, out ho_ModelCont, "border");

                m_hWnd.DispObj(m_hImage);
                m_hWnd.DispObj(ho_ModelCont);
                return true;
                
            }
            catch (HalconException ex)
            {
                return false;
            }
            finally
            {
                if (null != ho_Circle) ho_Circle.Dispose();
                if (null != ho_ImageReduced) ho_ImageReduced.Dispose();
                if (null != ho_Region) ho_Region.Dispose();
                if (null != ho_RegionSelect) ho_RegionSelect.Dispose();
                if (null != ho_SelRegion) ho_SelRegion.Dispose();
                if (null != ho_RegClosing) ho_RegClosing.Dispose();
                if (null != ho_ModelCont) ho_ModelCont.Dispose();
            }
        }
        public static bool CreateXLDModel(LocatInParams inPara, Circle circle, int nThd, out LocatOutParams outData)
        {
            outData = new LocatOutParams();
            //outData.dModelRow = 0;
            //outData.dModelCol = 0;
            //outData.dModelAngle = 0;
            HTuple hv_ModelID, hv_Area = new HTuple(), hv_AreaMax = new HTuple();
            HTuple  hv_Row, hv_Column, hv_Angle, hv_Score;

            HObject ho_Rectangle = null, ho_ImageReduced = null;
            HObject ho_Region = null, ho_SelRegion = null, ho_RegClosing = null, ho_RegionSelect = null;
            HObject ho_ModelCont = null;

            HOperatorSet.GenEmptyObj(out ho_Rectangle);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            HOperatorSet.GenEmptyObj(out ho_Region);
            HOperatorSet.GenEmptyObj(out ho_SelRegion);
            HOperatorSet.GenEmptyObj(out ho_RegClosing);
            HOperatorSet.GenEmptyObj(out ho_ModelCont);
            try
            {
                //HOperatorSet.GenRectangle1(out ho_Rectangle, rect1.dRectRow1, rect1.dRectCol1, rect1.dRectRow2, rect1.dRectCol2);
                HOperatorSet.GenCircle(out ho_Rectangle, circle.dRow, circle.dCol, circle.dRadius);
                m_hWnd.DispObj(ho_Rectangle);
                HOperatorSet.ReduceDomain(m_hImage, ho_Rectangle, out ho_ImageReduced);
                HOperatorSet.Threshold(ho_ImageReduced, out ho_Region, nThd, 255);
                HOperatorSet.FillUp(ho_Region, out ho_Region);
                HOperatorSet.Connection(ho_Region, out ho_Region);
                HOperatorSet.SelectShapeStd(ho_Region, out ho_SelRegion, "max_area", 70);
                HOperatorSet.RegionFeatures(ho_Region, "area", out hv_Area);
                HOperatorSet.RegionFeatures(ho_SelRegion, "area", out hv_AreaMax);
                HOperatorSet.SelectShape(ho_Region, out ho_RegionSelect, "area", "and", hv_Area.TupleMean() * 2, hv_AreaMax + 20);
                HOperatorSet.ClosingCircle(ho_RegionSelect, out ho_RegClosing, 5);
                HOperatorSet.Union1(ho_RegClosing, out ho_RegClosing);
                HOperatorSet.GenContourRegionXld(ho_RegClosing, out ho_ModelCont, "border");
                HOperatorSet.CreateShapeModelXld(ho_ModelCont, "auto", inPara.dAngleStart, inPara.dAngleEnd, "auto", "auto","ignore_local_polarity", 5, out hv_ModelID);
                HOperatorSet.FindShapeModel(m_hImage, hv_ModelID, new HTuple(inPara.dAngleStart).TupleRad(), new HTuple(inPara.dAngleEnd).TupleRad(), 0.5, 1, 0.5,
			                                "least_squares", 0, 0.9, out hv_Row, out hv_Column, out hv_Angle, out hv_Score);
                if (0 == hv_Row.TupleLength())
                {
                    MessageBox.Show("轮廓模板创建失败！");
                    return false;
                }
                else
                {
                    m_hWnd.DispObj(ho_ModelCont);
			        HOperatorSet.DispCross(m_hWnd,hv_Row,hv_Column,20,hv_Angle);
			        outData.dModelRow = hv_Row.D;
			        outData.dModelCol = hv_Column.D;
			        outData.dModelAngle = hv_Angle.D;
                    outData.nModelID = hv_ModelID.I;

                    return true;
                }
            }
            catch (HalconException ex)
            {
                MessageBox.Show("轮廓模板创建失败。");
                return false;
            }
            finally
            {
                if (null != ho_Rectangle) ho_Rectangle.Dispose();
                if (null != ho_ImageReduced) ho_ImageReduced.Dispose();
                if(null != ho_Region) ho_Region.Dispose();
                if (null != ho_SelRegion) ho_SelRegion.Dispose();
                if (null != ho_RegClosing) ho_RegClosing.Dispose();
                if (null != ho_ModelCont) ho_ModelCont.Dispose();
            }

        }
        //保存模板
        public static bool WriteModel(string strModelName,int nModelID)
        {
            try
            {
                if (nModelID <0)
                {
                    return false;
                }
                string strCurPath = Environment.CurrentDirectory.ToString();
                string strFilePath = strCurPath + "\\" + strModelName+ ".shm";//不能包含中文
                
                strFilePath = strFilePath.Replace("\\", "/");
                if(File.Exists(strFilePath))
                {
                    DialogResult dr= MessageBox.Show("模板文件已经存在，是否重盖？","提示：", MessageBoxButtons.OKCancel, MessageBoxIcon.Question);
                    if (dr != DialogResult.OK)
                    {
                        return false;
                    }
                    
                }
                HOperatorSet.WriteShapeModel(nModelID, strFilePath);
                MessageBox.Show("模板保存成功！");

                return true;
            }
            catch (System.Exception ex)
            {
                MessageBox.Show("模板保存失败！"+ ex.ToString());
                return false;
            }
           

        }

        //查找指定目录下的.shm文件
        public static bool FindModelFile(out List<string> strModelName)
        {
            strModelName = new List<string>();
            try
            {
                string strCurPath = Environment.CurrentDirectory.ToString();
                string strFilePath = strCurPath + "\\";//不能包含中文

                string[] filedir = Directory.GetFiles(strFilePath, "*.shm", SearchOption.AllDirectories);
                int n = 0;
                string str1 = ".shm";
                int num = str1.Length;
                foreach (string str in filedir)
                {
                    string newStr = str.Remove(0,strFilePath.Count());
                    newStr = newStr.TrimEnd('.','s','h','m');
                  //  string newName = newStr.Remove(newStr.Length- 1, num);
                    strModelName.Add(newStr);
                    n++;
                }
                return true;
             }
             catch (Exception ex)
            {
                return false;

             }
        }
        //读取模板//
        public static bool ReadTemplate(string strModelName, out int modelID)
        {
            modelID = -1;
            HTuple hv_ModelID = new HTuple();
            try
            {
                string strCurPath = Environment.CurrentDirectory.ToString();
                string strFilePath = strCurPath + "\\" + strModelName + ".shm";//不能包含中文
                HOperatorSet.ReadShapeModel(strFilePath, out hv_ModelID);
                modelID = hv_ModelID.I;
                return true;
            }
            catch (HalconException error)
            {
                MessageBox.Show("模板读取出错！");
                return false;
            }
        }
        //模板匹配
        public static bool FindModel(int nModelID, LocatInParams inPara, out LocatOutParams outParam)
        {
            outParam = new LocatOutParams();

            HTuple hv_Row = new HTuple(), hv_Column = new HTuple(), hv_Angle = new HTuple();
            HTuple hv_Score = new HTuple(), hv_HomMat2D = new HTuple();

            HObject ho_ModelContours = null, ho_ContoursAffinTrans =null;

            HOperatorSet.GenEmptyObj(out ho_ModelContours);
            HOperatorSet.GenEmptyObj(out ho_ContoursAffinTrans);
            try
            {
                double dScore = 0.95;
                while (dScore >=0.3)
                {
                    HOperatorSet.FindShapeModel(m_hImage, nModelID, new HTuple(inPara.dAngleStart).TupleRad(), new HTuple(inPara.dAngleEnd).TupleRad(), dScore, 1, 0.5,
			                                "least_squares", 0, 0.9, out hv_Row, out hv_Column, out hv_Angle, out hv_Score);
                    if (0 != hv_Row.TupleLength())
                    {
                        break;
                    }
                    dScore = dScore - 0.05;
                }
                if (0 == hv_Row.TupleLength())
                {
                    return false;
                }
                ho_ModelContours.Dispose();
                HOperatorSet.GetShapeModelContours(out ho_ModelContours, nModelID, 1);
                HOperatorSet.VectorAngleToRigid(0, 0, 0, hv_Row, hv_Column, hv_Angle, out hv_HomMat2D);
                HOperatorSet.AffineTransContourXld(ho_ModelContours, out ho_ContoursAffinTrans, hv_HomMat2D);

                //显示
                m_hWnd.DispObj(ho_ContoursAffinTrans);
                m_hWnd.DispCross(hv_Row.D, hv_Column.D, 60, hv_Angle.D);
                outParam.dModelRow = hv_Row.D;
                outParam.dModelCol = hv_Column.D;
                outParam.dModelAngle = hv_Angle.D;
                return true;
            }
            catch (HalconException ex)
            {
                return false;
            }

        }
        //拟合直线
        public static bool FitLine(LineParam lineParam, out Line lineOut)
        {
            lineOut.dStartRow = 0;
            lineOut.dStartCol = 0;
            lineOut.dEndRow = 0;
            lineOut.dEndCol = 0;

            HTuple hv_Width = new HTuple(), hv_Height = new HTuple(), hv_MetrologyHandle = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_RowBegin = new HTuple(), hv_ColBegin = new HTuple(), hv_RowEnd = new HTuple(), hv_ColEnd = new HTuple();
            HTuple hv_AllRow = new HTuple(), hv_AllColumn = new HTuple(), hv_Nr = new HTuple(), hv_Nc = new HTuple(), hv_Dist = new HTuple();
            HTuple hv_LineLen = new HTuple();


            HObject ho_MeasureCross = null, ho_MeasureLineContours = null, ho_MeasuredLines = null;
            HObject ho_ContLine = null;

            HOperatorSet.GenEmptyObj(out ho_MeasureCross);
            HOperatorSet.GenEmptyObj(out ho_MeasureLineContours);
            HOperatorSet.GenEmptyObj(out ho_MeasuredLines);
            HOperatorSet.GenEmptyObj(out ho_ContLine);
            try
            {
                m_hWnd.DispObj(m_hImage);
                HOperatorSet.GetImageSize(m_hImage,  out hv_Width, out hv_Height);
                int nThd = lineParam.EPMeasure.nMeasureThd;
                int minThd = nThd - 10;
                if (minThd < 1)
                    minThd = 1;
                int maxThd = nThd + 10;
                if (maxThd > 255)
                    maxThd = 255;
                bool bLoop = true;
                while (nThd>=minThd && nThd<=maxThd)
                {
                    HOperatorSet.CreateMetrologyModel(out hv_MetrologyHandle);
                    HOperatorSet.SetMetrologyModelImageSize(hv_MetrologyHandle, hv_Width, hv_Height);
                    //m_hWnd.DispLine(lineParam.lineIn.dStartRow, lineParam.lineIn.dStartCol, lineParam.lineIn.dEndRow, lineParam.lineIn.dEndCol);
                    HOperatorSet.AddMetrologyObjectLineMeasure(hv_MetrologyHandle, lineParam.lineIn.dStartRow, lineParam.lineIn.dStartCol, lineParam.lineIn.dEndRow, lineParam.lineIn.dEndCol,
                                 lineParam.EPMeasure.nMeasureLen1, lineParam.EPMeasure.nMeasureLen2, 1, nThd, new HTuple(), new HTuple(), out hv_Indices);
                    HOperatorSet.DistancePp(lineParam.lineIn.dStartRow, lineParam.lineIn.dStartCol, lineParam.lineIn.dEndRow, lineParam.lineIn.dEndCol, out hv_LineLen);
                    int nMeasureNum = (int)(hv_LineLen.D / 5.0);
                    //设置直线拟合参数
                    HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Indices, "num_instances", 1);
                    HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Indices, "measure_select", lineParam.EPMeasure.strSelect);
                    HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Indices, "measure_transition", lineParam.EPMeasure.strTransition);
                    HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Indices, "num_measures", nMeasureNum);
                    HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Indices, "min_score", 0.5);
                    HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Indices, "measure_interpolation", "bicubic");
                    HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Indices, "instances_outside_measure_regions", "true");
                    //获取直线拟合结果
                    HOperatorSet.ApplyMetrologyModel(m_hImage, hv_MetrologyHandle);
                    HOperatorSet.GetMetrologyObjectMeasures(out ho_MeasureLineContours, hv_MetrologyHandle, "all", "all", out hv_AllRow, out hv_AllColumn);
                    HOperatorSet.GenCrossContourXld(out ho_MeasureCross, hv_AllRow, hv_AllColumn, 8, 0);
                    HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Indices, "all", "result_type", "row_begin", out hv_RowBegin);
                    HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Indices, "all", "result_type", "column_begin", out hv_ColBegin);
                    HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Indices, "all", "result_type", "row_end", out hv_RowEnd);
                    HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Indices, "all", "result_type", "column_end", out hv_ColEnd);
                    HOperatorSet.GetMetrologyObjectResultContour(out ho_MeasuredLines, hv_MetrologyHandle, "all", "all", 1.5);
                    //清除直线拟合句柄
                    HOperatorSet.ClearMetrologyModel(hv_MetrologyHandle);
                    if (hv_AllRow.TupleLength() > 2)
                        break;
                    if (bLoop)
                    {
                        nThd = minThd-1;
                        bLoop = false;
                    }  
                    nThd = nThd + 1;
                }
                if (0 == hv_RowBegin.TupleLength() && hv_AllRow.TupleLength() >=2)
                {
                    HOperatorSet.GenContourPolygonXld(out ho_ContLine, hv_AllRow, hv_AllColumn);
                    HOperatorSet.FitLineContourXld(ho_ContLine, "tukey", -1, 0, 5, 2, out hv_RowBegin, out hv_ColBegin, out hv_RowEnd, out hv_ColEnd,
                                                   out hv_Nr, out hv_Nc, out hv_Dist);
                    if (hv_RowBegin.TupleLength() == 0)
                        return false;
                    HOperatorSet.GenRegionLine(out ho_MeasuredLines, hv_RowBegin, hv_ColBegin, hv_RowEnd, hv_ColEnd);

                }
                else if (1>=hv_AllRow.TupleLength())
                {
                    return false;
                }
		        lineOut.dStartRow = hv_RowBegin.D;
		        lineOut.dStartCol = hv_ColBegin.D;
		        lineOut.dEndRow = hv_RowEnd.D;
		        lineOut.dEndCol = hv_ColEnd.D;
                //

                m_hWnd.SetColor("yellow");
                m_hWnd.DispObj(ho_MeasureLineContours);
                m_hWnd.SetColor("green");
                m_hWnd.DispObj(ho_MeasureCross);
                SetShow(m_showParam);
		        m_hWnd.DispObj(ho_MeasuredLines);
                return true;
            }
            catch (HalconException error)
            {
                return false;
            }
            finally
            {
                if(null != ho_MeasureCross) ho_MeasureCross.Dispose();
                if(null != ho_MeasureLineContours) ho_MeasureLineContours.Dispose();
                if(null != ho_MeasuredLines) ho_MeasuredLines.Dispose();
                if (null != ho_ContLine) ho_ContLine.Dispose();
            }
        }
        //拟合圆
        public static bool FitCircle(CircleParam param, out Circle circleOut)
        {
            circleOut.dRow = 0;
            circleOut.dCol = 0;
            circleOut.dRadius = 0;

            HTuple hv_MetrologyHandle,hv_Width, hv_Height;
            HTuple hv_Index, hv_Rows = null, hv_Cols;
            HTuple hv_CircleRow = new HTuple(), hv_CircleCol = new HTuple(), hv_Radius = new HTuple();
            HTuple hv_StartPhi = new HTuple(), hv_EndPhi = new HTuple(), hv_PointOrder = new HTuple();

            HObject ho_Contours = null, ho_ContRect = null, ho_Circle = null;
            HObject ho_Cross = null;

            HOperatorSet.GenEmptyObj(out ho_Contours);
            HOperatorSet.GenEmptyObj(out ho_ContRect);
            HOperatorSet.GenEmptyObj(out ho_Circle);
            HOperatorSet.GenEmptyObj(out ho_Cross);
            try
            {
                m_hWnd.DispObj(m_hImage);
                m_hWnd.SetDraw("margin");

                int nMeasureNum = (int)((Math.PI * 2 * param.circleIn.dRadius) / (2*param.EPMeasure.nMeasureLen2));
                HOperatorSet.GetImageSize(m_hImage, out hv_Width, out hv_Height);

		        HOperatorSet.CreateMetrologyModel(out hv_MetrologyHandle);
		        HOperatorSet.SetMetrologyModelImageSize(hv_MetrologyHandle, hv_Width, hv_Height);
                HOperatorSet.AddMetrologyObjectCircleMeasure(hv_MetrologyHandle, param.circleIn.dRow, param.circleIn.dCol, param.circleIn.dRadius,
                                                             param.EPMeasure.nMeasureLen1, param.EPMeasure.nMeasureLen2, 1.2, param.EPMeasure.nMeasureThd, new HTuple(), new HTuple(), out hv_Index);
		        HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Index, "num_instances", 1);
		        HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Index, "num_measures", nMeasureNum);
		        HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Index, "measure_transition", param.EPMeasure.strTransition);
		        HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Index, "measure_select",  param.EPMeasure.strSelect);
                
		        HOperatorSet.ApplyMetrologyModel(m_hImage, hv_MetrologyHandle);
                HOperatorSet.GetMetrologyObjectMeasures(out ho_ContRect, hv_MetrologyHandle, "all", "all", out hv_Rows, out hv_Cols);
                if(0 == hv_Rows.TupleLength())
                    return false;
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Rows, hv_Cols, 6, 0);

                HOperatorSet.GetMetrologyObjectResultContour(out ho_Contours, hv_MetrologyHandle, "all", "all",  1.5);
                HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Index, "all", "result_type", "row", out hv_CircleRow);
                HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Index, "all", "result_type", "column", out hv_CircleCol);
                HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Index, "all", "result_type", "radius", out hv_Radius);
                if (0 == hv_CircleRow.TupleLength() && hv_Rows.TupleLength() >= 5)
                {
                    HOperatorSet.GenContourPolygonXld(out ho_Contours, hv_Rows, hv_Cols);
                    HOperatorSet.FitCircleContourXld(ho_Contours, "algebraic", -1, 0, 0, 3, 2, out hv_CircleRow, out hv_CircleCol, out hv_Radius,
                                                     out hv_StartPhi, out hv_EndPhi, out hv_PointOrder);

                }
                else if (0 == hv_CircleRow.TupleLength() && hv_Rows.TupleLength() < 5)
                    return false;
                HOperatorSet.GenCircle(out ho_Circle, hv_CircleRow, hv_CircleCol, hv_Radius);
		        HOperatorSet.ClearMetrologyModel(hv_MetrologyHandle);

                circleOut.dRow = hv_CircleRow.D;
                circleOut.dCol = hv_CircleCol.D;
                circleOut.dRadius = hv_Radius.D;

                //显示
                m_hWnd.SetColor("green");
                m_hWnd.DispObj(ho_Cross);
                m_hWnd.SetColor("red");
                m_hWnd.DispObj(ho_ContRect);
                SetShow(m_showParam);
                m_hWnd.DispObj(ho_Circle);
                m_hWnd.DispCross(hv_CircleRow, hv_CircleCol, hv_Radius/2, 0);
                return true;
            }
            catch (HalconException error)
            {
                return false;
            }
            finally
            {
                if(null != ho_Contours) ho_Contours.Dispose();
                if(null != ho_ContRect) ho_ContRect.Dispose();
                if(null != ho_Circle) ho_Circle.Dispose();
                if (null != ho_Cross) ho_Cross.Dispose();
            }
        }
        //拟合椭圆
        public static bool FitEllipse(EllipseParam param, out Ellipse ellipseOut)
        {
            ellipseOut = new Ellipse();

            HTuple hv_MetrologyHandle, hv_Width, hv_Height;
            HTuple hv_Index, hv_Rows = null, hv_Cols;
            HTuple hv_Row = new HTuple(), hv_Column = new HTuple(), hv_Phi = new HTuple(), hv_Radius1 = new HTuple(), hv_Radius2 = new HTuple();
            HTuple hv_StartPhi = new HTuple(), hv_EndPhi = new HTuple(), hv_PointOrder = new HTuple();

            HObject ho_Contours = null, ho_ContRect = null, ho_Ellipse = null;
            HObject ho_Cross = null;

            HOperatorSet.GenEmptyObj(out ho_Contours);
            HOperatorSet.GenEmptyObj(out ho_ContRect);
            HOperatorSet.GenEmptyObj(out ho_Ellipse);
            HOperatorSet.GenEmptyObj(out ho_Cross);
            try
            {
                m_hWnd.DispObj(m_hImage);
                //椭圆周长公式：L=2πb+4（a-b）
                int nMeasureNum = (int)((Math.PI * 2 * param.ellipseIn.dRadius2 + 4*(param.ellipseIn.dRadius1 - param.ellipseIn.dRadius2)) / (2 * param.EPMeasure.nMeasureLen2));
                HOperatorSet.GetImageSize(m_hImage, out hv_Width, out hv_Height);

                HOperatorSet.CreateMetrologyModel(out hv_MetrologyHandle);
                HOperatorSet.SetMetrologyModelImageSize(hv_MetrologyHandle, hv_Width, hv_Height);
                HOperatorSet.AddMetrologyObjectEllipseMeasure(hv_MetrologyHandle, param.ellipseIn.dRow, param.ellipseIn.dColumn, param.ellipseIn.dPhi, param.ellipseIn.dRadius1, param.ellipseIn.dRadius2,
                                                             param.EPMeasure.nMeasureLen1, param.EPMeasure.nMeasureLen2, 1.2, param.EPMeasure.nMeasureThd, new HTuple(), new HTuple(), out hv_Index);
                HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Index, "num_instances", 1);
                HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Index, "num_measures", nMeasureNum);
                HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Index, "measure_transition", param.EPMeasure.strTransition);
                HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Index, "measure_select", param.EPMeasure.strSelect);

                HOperatorSet.ApplyMetrologyModel(m_hImage, hv_MetrologyHandle);
                HOperatorSet.GetMetrologyObjectMeasures(out ho_ContRect, hv_MetrologyHandle, "all", "all", out hv_Rows, out hv_Cols);
                if (0 == hv_Rows.TupleLength())
                    return false;
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Rows, hv_Cols, 6, 0);

                HOperatorSet.GetMetrologyObjectResultContour(out ho_Contours, hv_MetrologyHandle, "all", "all", 1.5);
                HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Index, "all", "result_type", "row", out hv_Row);
                HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Index, "all", "result_type", "column", out hv_Column);
                HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Index, "all", "result_type", "phi", out hv_Phi);
                HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Index, "all", "result_type", "radius1", out hv_Radius1);
                HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Index, "all", "result_type", "radius2", out hv_Radius2);
                if (0 == hv_Row.TupleLength() && hv_Rows.TupleLength() >= 5)
                {
                    HOperatorSet.GenContourPolygonXld(out ho_Contours, hv_Rows, hv_Cols);
                    HOperatorSet.FitEllipseContourXld(ho_Contours, "fitzgibbon", -1, 0, 0, 200, 3, 2, out hv_Row, out hv_Column, out hv_Phi, out hv_Radius1, out hv_Radius2,
                                                      out hv_StartPhi, out hv_EndPhi, out hv_PointOrder);

                }
                else if (0 == hv_Row.TupleLength() && hv_Rows.TupleLength() < 5)
                    return false;
                HOperatorSet.GenEllipse(out ho_Ellipse, hv_Row, hv_Column, hv_Phi, hv_Radius1, hv_Radius2);
                HOperatorSet.ClearMetrologyModel(hv_MetrologyHandle);

                ellipseOut.dRow = hv_Row.D;
                ellipseOut.dColumn = hv_Column.D;
                ellipseOut.dPhi = hv_Phi.D;
                ellipseOut.dRadius1 = hv_Radius1.D;
                ellipseOut.dRadius2 = hv_Radius2.D;

                //显示
                m_hWnd.SetColor("green");
                m_ObjShow = ho_Cross;
                m_hWnd.DispObj(m_ObjShow);
                m_hWnd.SetColor("red");
                m_hWnd.DispObj(ho_ContRect);
                SetShow(m_showParam);
                m_ObjShow = m_ObjShow.ConcatObj(ho_Ellipse);
                m_hWnd.DispObj(m_ObjShow);
                m_hWnd.DispCross(hv_Row, hv_Column, hv_Radius2 / 5, hv_Phi);
                return true;
            }
            catch (HalconException error)
            {
                return false;
            }
            finally
            {
                if (null != ho_Contours) ho_Contours.Dispose();
                if (null != ho_ContRect) ho_ContRect.Dispose();
                if (null != ho_Ellipse) ho_Ellipse.Dispose();
                if (null != ho_Cross) ho_Cross.Dispose();
            }
        }
        //拟合矩形2
        public static bool FitRect2(Rect2Param param, out Rect2 rect2)
        {
            rect2 = new Rect2();

            HTuple hv_MetrologyHandle, hv_Width, hv_Height;
            HTuple hv_Index, hv_Rows = null, hv_Cols;
            HTuple hv_Row = new HTuple(), hv_Column = new HTuple(), hv_Phi = new HTuple(), hv_Length1 = new HTuple(), hv_Length2 = new HTuple();
            HTuple hv_StartPhi = new HTuple(), hv_EndPhi = new HTuple(), hv_PointOrder = new HTuple();

            HObject ho_Contours = null, ho_ContRect = null, ho_Rect2 = null;
            HObject ho_Cross = null;

            HOperatorSet.GenEmptyObj(out ho_Contours);
            HOperatorSet.GenEmptyObj(out ho_ContRect);
            HOperatorSet.GenEmptyObj(out ho_Rect2);
            HOperatorSet.GenEmptyObj(out ho_Cross);
            try
            {
                m_hWnd.DispObj(m_hImage);
                //长方形周长
                int nMeasureNum = (int)( 4 * param.rect2In.dLength1 + param.rect2In.dLength2) / (2 * param.EPMeasure.nMeasureLen2);
                HOperatorSet.GetImageSize(m_hImage, out hv_Width, out hv_Height);

                HOperatorSet.CreateMetrologyModel(out hv_MetrologyHandle);
                HOperatorSet.SetMetrologyModelImageSize(hv_MetrologyHandle, hv_Width, hv_Height);
                HOperatorSet.AddMetrologyObjectEllipseMeasure(hv_MetrologyHandle, param.rect2In.dRect2Row, param.rect2In.dRect2Col, param.rect2In.dPhi, param.rect2In.dLength1, param.rect2In.dLength2,
                                                             param.EPMeasure.nMeasureLen1, param.EPMeasure.nMeasureLen2, 1.2, param.EPMeasure.nMeasureThd, new HTuple(), new HTuple(), out hv_Index);
                HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Index, "num_instances", 1);
                HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Index, "num_measures", nMeasureNum);
                HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Index, "measure_transition", param.EPMeasure.strTransition);
                HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Index, "measure_select", param.EPMeasure.strSelect);

                HOperatorSet.ApplyMetrologyModel(m_hImage, hv_MetrologyHandle);
                HOperatorSet.GetMetrologyObjectMeasures(out ho_ContRect, hv_MetrologyHandle, "all", "all", out hv_Rows, out hv_Cols);
                if (0 == hv_Rows.TupleLength())
                    return false;
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Rows, hv_Cols, 6, 0);

                HOperatorSet.GetMetrologyObjectResultContour(out ho_Contours, hv_MetrologyHandle, "all", "all", 1.5);
                HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Index, "all", "result_type", "row", out hv_Row);
                HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Index, "all", "result_type", "column", out hv_Column);
                HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Index, "all", "result_type", "phi", out hv_Phi);
                HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Index, "all", "result_type", "length1", out hv_Length1);
                HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Index, "all", "result_type", "length2", out hv_Length2);
                if (0 == hv_Row.TupleLength() && hv_Rows.TupleLength() >= 5)
                {
                    HOperatorSet.GenContourPolygonXld(out ho_Contours, hv_Rows, hv_Cols);
                    HOperatorSet.FitRectangle2ContourXld(ho_Contours, "regression", -1, 0, 0, 3, 2, out hv_Row, out hv_Column, out hv_Phi, out hv_Length1, out hv_Length2,
                                                         out hv_PointOrder);

                }
                else if (0 == hv_Row.TupleLength() && hv_Rows.TupleLength() < 5)
                    return false;
                HOperatorSet.GenRectangle2(out ho_Rect2, hv_Row, hv_Column, hv_Phi, hv_Length1, hv_Length2);
                HOperatorSet.ClearMetrologyModel(hv_MetrologyHandle);

                rect2.dRect2Row = hv_Row.D;
                rect2.dRect2Col = hv_Column.D;
                rect2.dPhi = hv_Phi.D;
                rect2.dLength1 = hv_Length1.D;
                rect2.dLength2 = hv_Length2.D;

                //显示
                m_hWnd.SetColor("green");
                m_ObjShow = ho_Cross;
                m_hWnd.DispObj(m_ObjShow);
                m_hWnd.SetColor("red");
                m_hWnd.DispObj(ho_ContRect);
                SetShow(m_showParam);
                m_ObjShow = m_ObjShow.ConcatObj(ho_Rect2);
                m_hWnd.DispObj(m_ObjShow);
                m_hWnd.DispCross(hv_Row, hv_Column, hv_Length2 / 5, hv_Phi);
                return true;
            }
            catch (HalconException error)
            {
                return false;
            }
            finally
            {
                if (null != ho_Contours) ho_Contours.Dispose();
                if (null != ho_ContRect) ho_ContRect.Dispose();
                if (null != ho_Rect2) ho_Rect2.Dispose();
                if (null != ho_Cross) ho_Cross.Dispose();
            }
        }
        //双线段
        public static bool FitDoubleLine(DoubleLineParam param, out DoubleLineOut result)
        {
            /*边缘搜索方法：从中间往两边*/
            result = new DoubleLineOut();

            HObject ho_Rect2 = null, ho_ImageReduced = null;
            HObject ho_Border = null, ho_UnionContours = null, ho_SelectedXLD = null, ho_SortedContours = null;
            HObject ho_ObjSelected = null;

            HTuple hv_Number = null, hv_RowBegin = new HTuple(), hv_Orientation = new HTuple();
            HTuple hv_ColBegin = new HTuple(), hv_RowEnd = new HTuple(),hv_ColEnd = new HTuple(), hv_Nr = new HTuple();
            HTuple hv_Nc = new HTuple(), hv_Dist = new HTuple(), hv_DistMin = new HTuple(), hv_DistMax = new HTuple();
            HTuple hv_AngleLl = new HTuple();

            HOperatorSet.GenEmptyObj(out ho_Rect2);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            HOperatorSet.GenEmptyObj(out ho_Border);
            HOperatorSet.GenEmptyObj(out ho_UnionContours);
            HOperatorSet.GenEmptyObj(out ho_SelectedXLD);
            HOperatorSet.GenEmptyObj(out ho_SortedContours);
            HOperatorSet.GenEmptyObj(out ho_ObjSelected);
            try
            {
                HOperatorSet.GenRectangle2(out ho_Rect2, param.rect2.dRect2Row, param.rect2.dRect2Col, param.rect2.dPhi, param.rect2.dLength1, param.rect2.dLength2);
                m_hWnd.DispObj(ho_Rect2);
                HOperatorSet.ReduceDomain(m_hImage, ho_Rect2, out ho_ImageReduced);
                int nThd = param.nThd;
                int nStep = 5;
                hv_Number = 1;
                while(hv_Number !=2 && nThd <255)
                {
                    HOperatorSet.ThresholdSubPix(ho_ImageReduced, out ho_Border, nThd);
                    HOperatorSet.UnionAdjacentContoursXld(ho_Border, out ho_UnionContours, 5, 1, "attr_keep");
                    //m_hWnd.DispObj(ho_UnionContours);
                   // HOperatorSet.UnionCollinearContoursXld(ho_Border, out ho_UnionContours, 10, 1, 2, 0.1, "attr_keep");
                    //if (ho_UnionContours.CountObj() > 100)
                    //    continue;
                    HOperatorSet.SelectShapeXld(ho_UnionContours, out ho_SelectedXLD, (new HTuple("rect2_len1")).TupleConcat("rect2_len2"), "and",
                                               ((new HTuple(param.rect2.dLength2)) / 1.5).TupleConcat(0),(new HTuple(param.rect2.dLength2)*1.5).TupleConcat(10));
                    HOperatorSet.CountObj(ho_SelectedXLD, out hv_Number);
                    nThd = nThd + nStep;
                }
                if (2 != hv_Number.I)
                {
                    return false;
                }
                m_hWnd.DispObj(ho_SelectedXLD);
                //HOperatorSet.SortContoursXld(ho_SelectedXLD, out ho_SortedContours, "upper_left", "true", "column");
                List<Line> listLine = new List<Line>();
                LineParam lineParam = new LineParam();
                lineParam.EPMeasure.nMeasureLen1 = 5;
                lineParam.EPMeasure.nMeasureLen2 = param.EPMeasure.nMeasureLen2;
                lineParam.EPMeasure.nMeasureThd = param.EPMeasure.nMeasureThd;
                switch (param.nTransType)
                {
                    case 0: //中间黑两边白
                        lineParam.EPMeasure.strTransition = "positive";
                        break;
                    case 1: //中间白两边黑
                        lineParam.EPMeasure.strTransition = "negative";
                        break;
                    default:
                        break;
                }
                lineParam.EPMeasure.strSelect = "first";
                for (int i = 1; i <= 2; i++)
                {
                    HOperatorSet.SelectObj(ho_SelectedXLD, out ho_ObjSelected, i);
                    HOperatorSet.FitLineContourXld(ho_ObjSelected, "tukey", -1, 0, 5, 2, out hv_RowBegin, out hv_ColBegin, out hv_RowEnd, out hv_ColEnd,
                                                   out hv_Nr, out hv_Nc, out hv_Dist);

                    lineParam.lineIn.dStartRow = hv_RowBegin.D;
                    lineParam.lineIn.dStartCol = hv_ColBegin.D;
                    lineParam.lineIn.dEndRow = hv_RowEnd.D;
                    lineParam.lineIn.dEndCol = hv_ColEnd.D;

                    Line outLine = new Line();
                    if (!FitLine(lineParam, out outLine))
                    {
                        lineParam.lineIn.dStartRow = hv_RowEnd.D;
                        lineParam.lineIn.dStartCol = hv_ColEnd.D;
                        lineParam.lineIn.dEndRow = hv_RowBegin.D;
                        lineParam.lineIn.dEndCol = hv_ColBegin.D;
                        if (!FitLine(lineParam, out outLine))
                            return false;
                    }
                    listLine.Add(outLine);
                }
                result.lineLeft = listLine[0];
                result.lineRight = listLine[1];
                HOperatorSet.DistanceSl(listLine[0].dStartRow, listLine[0].dStartCol, listLine[0].dEndRow, listLine[0].dEndCol,
                                        listLine[1].dStartRow, listLine[1].dStartCol, listLine[1].dEndRow, listLine[1].dEndCol, out hv_DistMin, out hv_DistMax);
                result.dDist = (hv_DistMin.D + hv_DistMax.D) / 2.0;
                HOperatorSet.AngleLl(listLine[0].dStartRow, listLine[0].dStartCol, listLine[0].dEndRow, listLine[0].dEndCol,
                                     listLine[1].dEndRow, listLine[1].dEndCol, listLine[1].dStartRow, listLine[1].dStartCol, out hv_AngleLl);
                result.dAngle = hv_AngleLl.TupleDeg().D;

                //显示
                m_hWnd.DispObj(m_hImage);
                m_hWnd.SetColor("green");
                m_hWnd.DispLine(listLine[0].dStartRow, listLine[0].dStartCol, listLine[0].dEndRow, listLine[0].dEndCol);
                m_hWnd.DispLine(listLine[1].dStartRow, listLine[1].dStartCol, listLine[1].dEndRow, listLine[1].dEndCol);

                return true;
            }
            catch (HalconException ex)
            {
                return false;
            }
            finally
            {
                if (null != ho_Rect2) ho_Rect2.Dispose();
                if (null != ho_ImageReduced) ho_ImageReduced.Dispose();
                if (null != ho_Border) ho_Border.Dispose();
                if (null != ho_UnionContours) ho_UnionContours.Dispose();
                if (null != ho_SelectedXLD) ho_SelectedXLD.Dispose();
                if (null != ho_SortedContours) ho_SortedContours.Dispose();
                if (null != ho_ObjSelected) ho_ObjSelected.Dispose();
            }
        }

        public static bool GetRect2CornerPoints(Rect2 rect2, out double dLeftUpRow, out double dLeftUpCol,//左上角
                                                      out double dRightUpRow, out double dRightUpCol,//右上角
                                                      out double dLeftDownRow, out double dLeftDownCol, //左下角
                                                      out double dRightDownRow, out double dRightDownCol) //右下角
        {
            dLeftUpRow = 0;
            dLeftUpCol = 0;
            dRightUpRow = 0;
            dRightUpCol = 0;
            dLeftDownRow = 0;
            dLeftDownCol = 0;
            dRightDownRow = 0;
            dRightDownCol = 0;
            HObject ho_Cross = null;
            HTuple hv_tupleRow = new HTuple(), hv_tupleCol = new HTuple(), hv_Cos = new HTuple(), hv_Sin = new HTuple();
            HTuple hv_Indices, hv_SelectedCol0, hv_SelectedCol1;
            HTuple hv_SelectedCol2, hv_SelectedCol3;

            HOperatorSet.GenEmptyObj(out ho_Cross);
            try
            {
                HOperatorSet.TupleCos(rect2.dPhi, out hv_Cos);
                HOperatorSet.TupleSin(rect2.dPhi, out hv_Sin);
                double dRT_X = ((-1 * rect2.dLength1) * hv_Cos) - (rect2.dLength2 * hv_Sin);
                double dRT_Y = ((-1 * rect2.dLength1) * hv_Sin) + (rect2.dLength2 * hv_Cos);
                HOperatorSet.GenCrossContourXld(out ho_Cross, rect2.dRect2Row - dRT_Y, rect2.dRect2Col + dRT_X, 20, rect2.dPhi);
                hv_tupleRow = hv_tupleRow.TupleConcat(rect2.dRect2Row - dRT_Y);
                hv_tupleCol = hv_tupleCol.TupleConcat(rect2.dRect2Col + dRT_X);

                double dRB_X = (rect2.dLength1 * hv_Cos) - (rect2.dLength2 * hv_Sin);
                double dRB_Y = (rect2.dLength1 * hv_Sin) + (rect2.dLength2 * hv_Cos);
                HOperatorSet.GenCrossContourXld(out ho_Cross, rect2.dRect2Row - dRB_Y, rect2.dRect2Col + dRB_X, 20, rect2.dPhi);
                hv_tupleRow = hv_tupleRow.TupleConcat(rect2.dRect2Row - dRB_Y);
                hv_tupleCol = hv_tupleCol.TupleConcat(rect2.dRect2Col + dRB_X);

                double dLB_X = (rect2.dLength1 * hv_Cos) + (rect2.dLength2 * hv_Sin);
                double dLB_Y = (rect2.dLength1 * hv_Sin) - (rect2.dLength2 * hv_Cos);
                HOperatorSet.GenCrossContourXld(out ho_Cross, rect2.dRect2Row - dLB_Y, rect2.dRect2Col + dLB_X, 20, rect2.dPhi);
                hv_tupleRow = hv_tupleRow.TupleConcat(rect2.dRect2Row - dLB_Y);
                hv_tupleCol = hv_tupleCol.TupleConcat(rect2.dRect2Col + dLB_X);

                double dLT_X = ((-1 * rect2.dLength1) * hv_Cos) + (rect2.dLength2 * hv_Sin);
                double dLT_Y = ((-1 * rect2.dLength1) * hv_Sin) - (rect2.dLength2 * hv_Cos);
                HOperatorSet.GenCrossContourXld(out ho_Cross, rect2.dRect2Row - dLT_Y, rect2.dRect2Col + dLT_X, 20, rect2.dPhi);

                hv_tupleRow = hv_tupleRow.TupleConcat(rect2.dRect2Row - dLT_Y);
                hv_tupleCol = hv_tupleCol.TupleConcat(rect2.dRect2Col + dLT_X);

                HOperatorSet.TupleSortIndex(hv_tupleRow, out hv_Indices);
                HOperatorSet.TupleSelect(hv_tupleCol, hv_Indices[0], out hv_SelectedCol0);
                HOperatorSet.TupleSelect(hv_tupleCol, hv_Indices[1], out hv_SelectedCol1);
                //
                if (hv_SelectedCol0.D < hv_SelectedCol1.D)
                {
                    dLeftUpRow = hv_tupleRow.TupleSelect(hv_Indices[0]);
                    dLeftUpCol = hv_SelectedCol0;
                    dRightUpRow = hv_tupleRow.TupleSelect(hv_Indices[1]);
                    dRightUpCol = hv_SelectedCol1;
                }
                else
                {
                    dLeftUpRow = hv_tupleRow.TupleSelect(hv_Indices[1]);
                    dLeftUpCol = hv_SelectedCol1;
                    dRightUpRow = hv_tupleRow.TupleSelect(hv_Indices[0]);
                    dRightUpCol = hv_SelectedCol0;
                }
                //
                HOperatorSet.TupleSelect(hv_tupleCol, hv_Indices[2], out hv_SelectedCol2);
                HOperatorSet.TupleSelect(hv_tupleCol, hv_Indices[3], out hv_SelectedCol3);
                if (hv_SelectedCol2.D < hv_SelectedCol3.D)
                {
                    dLeftDownRow = hv_tupleRow.TupleSelect(hv_Indices[2]);
                    dLeftDownCol = hv_SelectedCol2;
                    dRightDownRow = hv_tupleRow.TupleSelect(hv_Indices[3]);
                    dRightDownCol = hv_SelectedCol3;
                }
                else
                {
                    dLeftDownRow = hv_tupleRow.TupleSelect(hv_Indices[3]);
                    dLeftDownCol = hv_SelectedCol3;
                    dRightDownRow = hv_tupleRow.TupleSelect(hv_Indices[2]);
                    dRightDownCol = hv_SelectedCol2;
                }
                return true;

            }
            catch (System.Exception ex)
            {
                return false;
            }
            finally
            {
                if (null != ho_Cross) ho_Cross.Dispose();
            }

        }        
        //直线到直线的距离
        public static bool IntersectionL2L(Line line1, Line line2, out PointF interPoint, out double dDistMin, out double dDistMax,out double dAngle)
        {
            interPoint = new PointF();
            dDistMin = 0;
            dDistMax = 0;
            dAngle = 0;

            HTuple hv_DistMin = new HTuple(), hv_DistMax = new HTuple(), hv_InterRow = new HTuple(), hv_InterCol = new HTuple();
            HTuple hv_isOverlapping = new HTuple(), hv_isParallel = new HTuple(), hv_angle = new HTuple();

            try
            {
                HOperatorSet.DistanceSs(line1.dStartRow, line1.dStartCol, line1.dEndRow, line1.dEndCol,
                                        line2.dStartRow, line2.dStartCol, line2.dEndRow, line2.dEndCol, out hv_DistMin, out hv_DistMax);
                if(0 == hv_DistMin.D)//两条线段相交
                {
                    HOperatorSet.IntersectionSegments(line1.dStartRow, line1.dStartCol, line1.dEndRow, line1.dEndCol,
                                                      line2.dStartRow, line2.dStartCol, line2.dEndRow, line2.dEndCol, out hv_InterRow, out hv_InterCol, out hv_isOverlapping);
                }
                else //两条线段不相交
                {
                    HOperatorSet.IntersectionLl(line1.dStartRow, line1.dStartCol, line1.dEndRow, line1.dEndCol,
                                                line2.dStartRow, line2.dStartCol, line2.dEndRow, line2.dEndCol, out hv_InterRow, out hv_InterCol, out hv_isParallel);
                    if(hv_isParallel)
                    {
                        HOperatorSet.AngleLl(line1.dStartRow, line1.dStartCol, line1.dEndRow, line1.dEndCol,
                                             line2.dStartRow, line2.dStartCol, line2.dEndRow, line2.dEndCol, out hv_angle);
                    }
                }
                interPoint.X = (float)hv_InterCol.D;
                interPoint.Y = (float)hv_InterRow.D;
                dDistMin = hv_DistMin.D;
                dDistMax = hv_DistMax.D;
                dAngle = hv_angle.D;
                HOperatorSet.DistanceSl(line1.dStartRow, line1.dStartCol, line1.dEndRow, line1.dEndCol,
                                        line2.dStartRow, line2.dStartCol, line2.dEndRow, line2.dEndCol, out hv_DistMin, out hv_DistMax);
                if (0 == hv_DistMax.TupleLength())
                {
                    return false;
                }
                return true;
            }
            catch (System.Exception ex)
            {
                MessageBox.Show(ex.ToString());
                return false;
            }
        }

        //点到直线的距离
        public static bool DistPL(double dRow, double dCol, Line line, out double dDistPl)
        {
            dDistPl = -1;
            HTuple hv_Distance = null;

            try
            {
                dDistPl = -1;
                HOperatorSet.DistancePl(dRow, dCol, line.dStartRow, line.dStartCol, line.dEndRow, line.dEndCol, out hv_Distance);
                if (0 == hv_Distance.TupleLength())
                {
                    return false;
                }
                dDistPl = hv_Distance.D;
                return true;
            }
            catch (System.Exception ex)
            {
                MessageBox.Show(ex.ToString());
                return false;
            }
        }
        //
        public static void list_image_files(HTuple hv_ImageDirectory, HTuple hv_Extensions, HTuple hv_Options, out HTuple hv_ImageFiles)
        {
            // Local iconic variables 

            // Local control variables 

            HTuple hv_HalconImages = null, hv_OS = null;
            HTuple hv_Directories = null, hv_Index = null, hv_Length = null;
            HTuple hv_network_drive = null, hv_Substring = new HTuple();
            HTuple hv_FileExists = new HTuple(), hv_AllFiles = new HTuple();
            HTuple hv_i = new HTuple(), hv_Selection = new HTuple();
            HTuple hv_Extensions_COPY_INP_TMP = hv_Extensions.Clone();
            HTuple hv_ImageDirectory_COPY_INP_TMP = hv_ImageDirectory.Clone();

            // Initialize local and output iconic variables 
            //This procedure returns all files in a given directory
            //with one of the suffixes specified in Extensions.
            //
            //input parameters:
            //ImageDirectory: as the name says
            //   If a tuple of directories is given, only the images in the first
            //   existing directory are returned.
            //   If a local directory is not found, the directory is searched
            //   under %HALCONIMAGES%/ImageDirectory. If %HALCONIMAGES% is not set,
            //   %HALCONROOT%/images is used instead.
            //Extensions: A string tuple containing the extensions to be found
            //   e.g. ['png','tif',jpg'] or others
            //If Extensions is set to 'default' or the empty string '',
            //   all image suffixes supported by HALCON are used.
            //Options: as in the operator list_files, except that the 'files'
            //   option is always used. Note that the 'directories' option
            //   has no effect but increases runtime, because only files are
            //   returned.
            //
            //output parameter:
            //ImageFiles: A tuple of all found image file names
            //
            if ((int)((new HTuple((new HTuple(hv_Extensions_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
                new HTuple(hv_Extensions_COPY_INP_TMP.TupleEqual(""))))).TupleOr(new HTuple(hv_Extensions_COPY_INP_TMP.TupleEqual(
                "default")))) != 0)
            {
                hv_Extensions_COPY_INP_TMP = new HTuple();
                hv_Extensions_COPY_INP_TMP[0] = "ima";
                hv_Extensions_COPY_INP_TMP[1] = "tif";
                hv_Extensions_COPY_INP_TMP[2] = "tiff";
                hv_Extensions_COPY_INP_TMP[3] = "gif";
                hv_Extensions_COPY_INP_TMP[4] = "bmp";
                hv_Extensions_COPY_INP_TMP[5] = "jpg";
                hv_Extensions_COPY_INP_TMP[6] = "jpeg";
                hv_Extensions_COPY_INP_TMP[7] = "jp2";
                hv_Extensions_COPY_INP_TMP[8] = "jxr";
                hv_Extensions_COPY_INP_TMP[9] = "png";
                hv_Extensions_COPY_INP_TMP[10] = "pcx";
                hv_Extensions_COPY_INP_TMP[11] = "ras";
                hv_Extensions_COPY_INP_TMP[12] = "xwd";
                hv_Extensions_COPY_INP_TMP[13] = "pbm";
                hv_Extensions_COPY_INP_TMP[14] = "pnm";
                hv_Extensions_COPY_INP_TMP[15] = "pgm";
                hv_Extensions_COPY_INP_TMP[16] = "ppm";
                //
            }
            if ((int)(new HTuple(hv_ImageDirectory_COPY_INP_TMP.TupleEqual(""))) != 0)
            {
                hv_ImageDirectory_COPY_INP_TMP = ".";
            }
            HOperatorSet.GetSystem("image_dir", out hv_HalconImages);
            HOperatorSet.GetSystem("operating_system", out hv_OS);
            if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Win"))) != 0)
            {
                hv_HalconImages = hv_HalconImages.TupleSplit(";");
            }
            else
            {
                hv_HalconImages = hv_HalconImages.TupleSplit(":");
            }
            hv_Directories = hv_ImageDirectory_COPY_INP_TMP.Clone();
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_HalconImages.TupleLength()
                )) - 1); hv_Index = (int)hv_Index + 1)
            {
                hv_Directories = hv_Directories.TupleConcat(((hv_HalconImages.TupleSelect(hv_Index)) + "/") + hv_ImageDirectory_COPY_INP_TMP);
            }
            HOperatorSet.TupleStrlen(hv_Directories, out hv_Length);
            HOperatorSet.TupleGenConst(new HTuple(hv_Length.TupleLength()), 0, out hv_network_drive);
            if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Win"))) != 0)
            {
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Length.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                {
                    if ((int)(new HTuple(((((hv_Directories.TupleSelect(hv_Index))).TupleStrlen())).TupleGreater(1))) != 0)
                    {
                        HOperatorSet.TupleStrFirstN(hv_Directories.TupleSelect(hv_Index), 1, out hv_Substring);
                        if ((int)(new HTuple(hv_Substring.TupleEqual("//"))) != 0)
                        {
                            if (hv_network_drive == null)
                                hv_network_drive = new HTuple();
                            hv_network_drive[hv_Index] = 1;
                        }
                    }
                }
            }
            hv_ImageFiles = new HTuple();
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Directories.TupleLength() )) - 1); hv_Index = (int)hv_Index + 1)
            {
                HOperatorSet.FileExists(hv_Directories.TupleSelect(hv_Index), out hv_FileExists);
                if ((int)(hv_FileExists) != 0)
                {
                    HOperatorSet.ListFiles(hv_Directories.TupleSelect(hv_Index), (new HTuple("files")).TupleConcat(
                        hv_Options), out hv_AllFiles);
                    hv_ImageFiles = new HTuple();
                    for (hv_i = 0; (int)hv_i <= (int)((new HTuple(hv_Extensions_COPY_INP_TMP.TupleLength())) - 1); hv_i = (int)hv_i + 1)
                    {
                        HOperatorSet.TupleRegexpSelect(hv_AllFiles, (((".*" + (hv_Extensions_COPY_INP_TMP.TupleSelect(
                            hv_i))) + "$")).TupleConcat("ignore_case"), out hv_Selection);
                        hv_ImageFiles = hv_ImageFiles.TupleConcat(hv_Selection);
                    }
                    HOperatorSet.TupleRegexpReplace(hv_ImageFiles, (new HTuple("\\\\")).TupleConcat(
                        "replace_all"), "/", out hv_ImageFiles);
                    if ((int)(hv_network_drive.TupleSelect(hv_Index)) != 0)
                    {
                        HOperatorSet.TupleRegexpReplace(hv_ImageFiles, (new HTuple("//")).TupleConcat(
                            "replace_all"), "/", out hv_ImageFiles);
                        hv_ImageFiles = "/" + hv_ImageFiles;
                    }
                    else
                    {
                        HOperatorSet.TupleRegexpReplace(hv_ImageFiles, (new HTuple("//")).TupleConcat(
                            "replace_all"), "/", out hv_ImageFiles);
                    }

                    return;
                }
            }

            return;
        }

        ////圆与直线的交点
        //public static bool Circle_Inter_Line(CircleLineInterParam circleLineParam, out PointF intersection)
        //{
        //    intersection = new PointF();

        //    HTuple hv_InterRow = new HTuple(), hv_InterCol = new HTuple();
        //    HTuple hv_Dist1 = new HTuple(), hv_Dist2 = new HTuple();
        //    HTuple hv_Row = new HTuple(), hv_Col = new HTuple();
            
        //    try
        //    {
        //        Circle circle = new Circle();
        //        if (!FitCircle(circleLineParam.circleParam, out circle))
        //            return false;
        //        Line line = new Line();
        //        if (!FitLine(circleLineParam.lineParam, out line))
        //            return false;
        //        HOperatorSet.IntersectionLineCircle(line.dStartRow, line.dStartCol, line.dEndRow, line.dEndCol,  circle.dRow, circle.dCol, circle.dRadius,
        //                                            new HTuple(0), new HTuple(Math.PI * 2), "positive", out hv_InterRow, out hv_InterCol);
        //        if (1 >= hv_InterRow.TupleLength())
        //            return false;

        //        double dHalfRow = (hv_InterRow[0] + hv_InterRow[1]) / 2.0;
        //        double dHalfCol = (hv_InterCol[0] + hv_InterCol[1]) / 2.0;
        //        HOperatorSet.DistancePp(dHalfRow, dHalfCol, line.dStartRow, line.dStartCol, out hv_Dist1);
        //        HOperatorSet.DistancePp(dHalfRow, dHalfCol, line.dEndRow, line.dEndCol, out hv_Dist2);
        //        double dLineRow=0, dLineCol = 0;
        //        if (hv_Dist1.D > hv_Dist2.D)
        //        {
        //            dLineRow = line.dStartRow;
        //            dLineCol = line.dStartCol;
        //        }
        //        else
        //        {
        //            dLineRow = line.dEndRow;
        //            dLineCol = line.dEndCol;
        //        }
        //        HOperatorSet.IntersectionSegmentCircle(dLineRow, dLineCol, dHalfRow, dHalfCol, circle.dRow, circle.dCol, circle.dRadius,
        //                                            new HTuple(0), new HTuple(Math.PI * 2), "positive", out hv_Row, out hv_Col);
        //        if (1 != hv_Row.TupleLength())
        //            return false;
        //        intersection.X = (float)hv_Col.D;
        //        intersection.Y = (float)hv_Row.D;
        //        //显示
        //        //m_hWnd.DispObj(m_hImage);
        //        m_hWnd.SetColor("green");
        //        m_hWnd.DispCircle(circle.dRow, circle.dCol, circle.dRadius);
        //        m_hWnd.DispLine(dLineRow, dLineCol, dHalfRow, dHalfCol);
        //        m_hWnd.SetColor("red");
        //        m_hWnd.DispCross(hv_Row, hv_Col, 20, 0);
        //        return true; 
        //    }
        //    catch(HalconException error)
        //    {
        //        return false;
        //    }
        //    finally
        //    {

        //    }
        //}

        ////直线与直线的交点
        //public static bool Line_Inter_Line(LineLineInterParam lineLineParam, out PointP intersection)
        //{
        //    intersection = new PointP();
        //    HTuple hv_InterRow = new HTuple(), hv_InterCol = new HTuple(), hv_isParallel = new HTuple();

        //    try
        //    {
        //        Line line1 = new Line();
        //        if (!FitLine(lineLineParam.arrayLineParam[0], out line1))
        //            return false;
        //        Line line2 = new Line();
        //        if (!FitLine(lineLineParam.arrayLineParam[1], out line2))
        //            return false;
        //        HOperatorSet.IntersectionLl(line1.dStartRow, line1.dStartCol, line1.dEndRow, line1.dEndCol,
        //                                    line2.dStartRow, line2.dStartCol, line2.dEndRow, line2.dEndCol, out hv_InterRow, out hv_InterCol, out hv_isParallel);
        //        if (1 != hv_InterRow.TupleLength())
        //            return false;
        //        intersection.dRow = hv_InterRow.D;
        //        intersection.dCol = hv_InterCol.D;
        //        //显示
        //        m_hWnd.SetColor("green");
        //        m_hWnd.DispLine(line1.dStartRow, line1.dStartCol, line1.dEndRow, line1.dEndCol);
        //        m_hWnd.DispLine(line2.dStartRow, line2.dStartCol, line2.dEndRow, line2.dEndCol);
        //        m_hWnd.SetColor("red");
        //        m_hWnd.DispCross(hv_InterRow, hv_InterCol, 40, 0);
                
        //        return true;

        //    }
        //    catch(HalconException error)
        //    {
        //        ErrorPrinter.WriteLine(string.Format("直线与直线的交点计算出错！錯誤信息：{0}", error.Message), ETraceDisplay.LISTBOX);
        //        return false;
        //    }
        //}

        public static void WriteStringtoImage(int nRowSite, string str)
        {
            try
            {
                m_hWnd.SetTposition(nRowSite, 20);
                m_hWnd.WriteString(str);
            }
            catch(HalconException error)
            {
                //ErrorPrinter.WriteLine(string.Format("显示字符出错！错误信息：{0}", error.Message), ETraceDisplay.LISTBOX);
            }
            return;
        }

        #endregion

        #region 标定
        /*圆点标定板*/
        public static bool CirclePointCalib(CirclePointCalibParam param, out double dMeanDiam, out CalibrateResult calibResult)
        {
            dMeanDiam = 0;
            calibResult = new CalibrateResult();

            HTuple hv_DiamVal= new HTuple(), hv_areas = new HTuple(), hv_areaDiff = new HTuple();
            HTuple hv_area = new HTuple(), hv_row = new HTuple(), hv_column = new HTuple();

            HObject ho_Region = null, ho_SelectedRegions = null, ho_UnionRegions = null;
            HObject ho_RegionDilaX = null, ho_RegionDilaXConnect = null;
            HObject ho_SelObj = null, ho_RegionInter = null, ho_SortRegion = null;
            HObject ho_RegionDilaY = null;

            HOperatorSet.GenEmptyObj(out ho_Region);
            HOperatorSet.GenEmptyObj(out ho_SelectedRegions);
            HOperatorSet.GenEmptyObj(out ho_UnionRegions);
            HOperatorSet.GenEmptyObj(out ho_RegionDilaX);
            HOperatorSet.GenEmptyObj(out ho_RegionDilaXConnect);
            HOperatorSet.GenEmptyObj(out ho_SelObj);
            HOperatorSet.GenEmptyObj(out ho_RegionInter);
            HOperatorSet.GenEmptyObj(out ho_SortRegion);
            HOperatorSet.GenEmptyObj(out ho_RegionDilaY);

            try
            {
                HTuple hv_channels = new HTuple();
                HOperatorSet.CountChannels(m_hImage, out hv_channels);
                if (1 != hv_channels.I)
                    HOperatorSet.Rgb1ToGray(m_hImage, out m_hImage);
                HOperatorSet.Threshold(m_hImage, out ho_Region, 0, param.nThd); 
                HOperatorSet.Connection(ho_Region, out ho_Region);
                if (param.dCircularity > 1)
                    param.dCircularity = 1;
                HOperatorSet.SelectShape(ho_Region, out ho_SelectedRegions, "circularity", "and", param.dCircularity, 1);
                HOperatorSet.RegionFeatures(ho_SelectedRegions, "area", out hv_areas);
                HTuple hv_max = hv_areas.TupleMax();
                HTuple hv_min = hv_areas.TupleMin();
                HOperatorSet.TupleDifference(hv_areas, hv_max.TupleConcat(hv_min), out hv_areaDiff);
                double dAreaMean = hv_areaDiff.TupleMean();
                HOperatorSet.SelectShape(ho_SelectedRegions, out ho_SelectedRegions, "area", "and", dAreaMean*0.8, dAreaMean * 2);
                HOperatorSet.RegionFeatures(ho_SelectedRegions, "max_diameter", out hv_DiamVal);
                m_hWnd.DispObj(m_hImage);
                m_hWnd.DispObj(ho_SelectedRegions);
                dMeanDiam = (param.dCircleDiam / hv_DiamVal).TupleMean();
                //
                HOperatorSet.Union1(ho_SelectedRegions, out ho_UnionRegions);
                //计算X方向的圆点间距
                HOperatorSet.DilationRectangle1(ho_UnionRegions, out ho_RegionDilaX, imageWidth / 2, 1);
                HOperatorSet.Connection(ho_RegionDilaX, out ho_RegionDilaXConnect);
                int nCol = ho_RegionDilaXConnect.CountObj();
                HTuple hv_xLen = new HTuple();
                for (int i = 1; i < nCol; i++)
                {
                    HOperatorSet.SelectObj(ho_RegionDilaXConnect, out ho_SelObj, i);
                    HOperatorSet.Intersection(ho_SelectedRegions, ho_SelObj, out ho_RegionInter);
                    HOperatorSet.SortRegion(ho_RegionInter, out ho_SortRegion, "first_point", "true","column");
                    HOperatorSet.AreaCenter(ho_SortRegion, out hv_area, out hv_row, out hv_column);
                    for(int j=0; j< hv_column.TupleLength()-2; j++)
                    {
                        double dXLen = Math.Sqrt(Math.Pow((hv_column[j + 1] - hv_column[j]), 2) + Math.Pow((hv_row[j + 1] - hv_row[j]), 2));
                        hv_xLen = hv_xLen.TupleConcat(dXLen);
                    }
                }
                calibResult.dXCalib = param.dCircleSpace/hv_xLen.TupleMean();
                //计算Y方向的圆点间距
                HOperatorSet.DilationRectangle1(ho_SelectedRegions, out ho_RegionDilaY, 1, imageHeight / 2);
                HOperatorSet.Connection(ho_RegionDilaY, out ho_RegionDilaY);
                int nRow = ho_RegionDilaY.CountObj();
                HTuple hv_yLen = new HTuple();
                for(int m=1; m<nRow;m++)
                {
                    HOperatorSet.SelectObj(ho_RegionDilaY, out ho_SelObj, m);
                    HOperatorSet.Intersection(ho_SelectedRegions, ho_SelObj, out ho_RegionInter);
                    ho_SortRegion.Dispose();
                    HOperatorSet.SortRegion(ho_RegionInter, out ho_SortRegion, "first_point", "true", "row");
                    HOperatorSet.AreaCenter(ho_SortRegion, out hv_area, out hv_row, out hv_column);
                    for(int n=0; n< hv_row.TupleLength()-2;n++)
                    {
                        double dYLen = Math.Sqrt(Math.Pow((hv_column[n + 1] - hv_column[n]), 2) + Math.Pow((hv_row[n + 1] - hv_row[n]), 2));
                        hv_yLen = hv_yLen.TupleConcat(dYLen);
                    }
                }
                calibResult.dYCalib = param.dCircleSpace / hv_yLen.TupleMean();
                return true;
            }
            catch(HalconException error)
            {
                return false;
            }
            finally
            {
                if(null != ho_Region) ho_Region.Dispose();
                if(null != ho_SelectedRegions) ho_SelectedRegions.Dispose();
                if (null != ho_UnionRegions) ho_UnionRegions.Dispose();
                if (null != ho_RegionDilaX) ho_RegionDilaX.Dispose();
                if(null != ho_RegionDilaXConnect) ho_RegionDilaXConnect.Dispose();
                if(null != ho_SelObj) ho_SelObj.Dispose();
                if(null != ho_RegionInter) ho_RegionInter.Dispose();
                if(null != ho_SortRegion) ho_SortRegion.Dispose();
                if (null != ho_RegionDilaY) ho_RegionDilaY.Dispose();
            }
        }
        /*棋盘格标定*/
        public static bool CheckerCalib(CheckerCalibParam param, out CalibrateResult calibResult)
        {
            calibResult = new CalibrateResult();

            HObject ho_Region = null, ho_RegionOpening = null, ho_ConnectedRegions = null;
            HObject ho_SelectedRegions = null, ho_SortedRegions = null, ho_ObjectSelected = null;

            HTuple hv_Number = new HTuple(), hv_Areas = new HTuple(), hv_AreaDiff = new HTuple();
            HTuple hv_Dist1 = new HTuple(), hv_Dist2 = new HTuple();
            
            HOperatorSet.GenEmptyObj(out ho_Region);
            HOperatorSet.GenEmptyObj(out ho_RegionOpening);
            HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
            HOperatorSet.GenEmptyObj(out ho_SelectedRegions);
            HOperatorSet.GenEmptyObj(out ho_SortedRegions);
            HOperatorSet.GenEmptyObj(out ho_ObjectSelected);

            try
            {
                HOperatorSet.Threshold(m_hImage, out ho_Region, 0, param.nThreshold);
                HOperatorSet.OpeningCircle(ho_Region, out ho_RegionOpening, 2);
                HOperatorSet.Connection(ho_RegionOpening, out ho_ConnectedRegions);
                HOperatorSet.RegionFeatures(ho_ConnectedRegions, "area", out hv_Areas);
                HTuple hv_max = hv_Areas.TupleMax();
                HTuple hv_Min = hv_Areas.TupleMin();
                HOperatorSet.TupleDifference(hv_Areas, hv_max.TupleConcat(hv_Min), out hv_AreaDiff);
                HTuple hv_AreaMean = hv_AreaDiff.TupleMean();
                HOperatorSet.SelectShape(ho_ConnectedRegions, out ho_SelectedRegions, new HTuple("rectangularity").TupleConcat("area"), "and",
                                                                                      new HTuple(param.dRectangularity).TupleConcat(hv_AreaMean * 0.8),
                                                                                      new HTuple(1).TupleConcat(hv_AreaMean * 2));
                HOperatorSet.ShapeTrans(ho_SelectedRegions, out ho_SelectedRegions, "rectangle2");
                HOperatorSet.CountObj(ho_SelectedRegions, out hv_Number);
                if (0 == hv_Number.I)
                    return false;
                HOperatorSet.SortRegion(ho_SelectedRegions, out ho_SortedRegions, "first_point", "true", "row");

                HTuple hv_x_Len = new HTuple();
                HTuple hv_y_Len = new HTuple();

                for (int i = 1; i <= hv_Number.I; i++)
                {
                    HOperatorSet.SelectObj(ho_SortedRegions, out ho_ObjectSelected, i);
                    if (1 == ho_ObjectSelected.CountObj())
                    {
                        HOperatorSet.RegionFeatures(ho_ObjectSelected, "rect2_len1", out hv_Dist1);
                        HOperatorSet.RegionFeatures(ho_ObjectSelected, "rect2_len2", out hv_Dist2);
                        hv_x_Len = (hv_x_Len.TupleConcat(2.0 * hv_Dist1));
                        hv_y_Len = (hv_y_Len.TupleConcat(2.0 * hv_Dist2));
                    }
                }
                if (0 == hv_x_Len.TupleLength())
                    return false;
                calibResult.dXCalib = param.dLength / (hv_x_Len.TupleMean().D);
                calibResult.dYCalib = param.dLength / (hv_y_Len.TupleMean().D);
                //显示
                m_hWnd.DispObj(m_hImage);
                m_hWnd.DispObj(ho_SortedRegions);
                
                return true;
            }
            catch (HalconException ex)
            {
                return false;
            }
            finally
            {
                if (null != ho_Region) ho_Region.Dispose();
                if(null != ho_RegionOpening) ho_RegionOpening.Dispose();
                if(null != ho_ConnectedRegions) ho_ConnectedRegions.Dispose();
                if(null != ho_SelectedRegions) ho_SelectedRegions.Dispose();
                if(null != ho_SortedRegions) ho_SortedRegions.Dispose();
                if(null != ho_ObjectSelected) ho_ObjectSelected.Dispose();
            }
        }
        /*二维码标定*/
        public static bool BarCode2DCalib(Code2DCalibParam param, out CalibrateResult calibResult)
        {
            calibResult = new CalibrateResult();

            HTuple hv_width = new HTuple(), hv_height = new HTuple();
            HTuple hv_DataCodeHandle = new HTuple(), hv_ResultHandles = new HTuple(), hv_DecodedDataString = new HTuple();
            HTuple hv_TupleNum = new HTuple(), hv_area = new HTuple(),  hv_row =new HTuple(), hv_column = new HTuple(), hv_pointOrder = new HTuple();
            HTuple hv_indices = new HTuple(), hv_dist = new HTuple(), hv_SubString = new HTuple(), hv_SubString1 = new HTuple();
            HTuple hv_BarCodeDist = new HTuple();

            HObject ho_SymbolXlds = null, ho_SymbolRegion = null, ho_HRegion = null, ho_HSortRegion = null;
            HObject ho_VRegion = null, ho_VSortRegion = null;
            HObject ho_selectObj = null, ho_ReiongInter = null, ho_ImgReduced = null;

            HOperatorSet.GenEmptyObj(out ho_SymbolXlds);
            HOperatorSet.GenEmptyObj(out ho_SymbolRegion);
            HOperatorSet.GenEmptyObj(out ho_HRegion);
            HOperatorSet.GenEmptyObj(out ho_HSortRegion);
            HOperatorSet.GenEmptyObj(out ho_VRegion);
            HOperatorSet.GenEmptyObj(out ho_VSortRegion);
            HOperatorSet.GenEmptyObj(out ho_selectObj);
            HOperatorSet.GenEmptyObj(out ho_ReiongInter);
            HOperatorSet.GenEmptyObj(out ho_ImgReduced);

            try
            {
                HOperatorSet.GetImageSize(m_hImage, out hv_width, out hv_height);
                HOperatorSet.CreateDataCode2dModel(param.strCodeType, new HTuple(), new HTuple(), out hv_DataCodeHandle);
                HOperatorSet.FindDataCode2d(m_hImage, out ho_SymbolXlds, hv_DataCodeHandle, "stop_after_result_num", 99, out hv_ResultHandles, out hv_DecodedDataString);
                if (0 == ho_SymbolXlds.CountObj())
                    return false;
                HOperatorSet.AreaCenterXld(ho_SymbolXlds, out hv_area, out hv_row, out hv_column, out hv_pointOrder);
                for (int i =0; i<ho_SymbolXlds.CountObj();i++)
                {
                    m_hWnd.SetTposition(hv_row.TupleSelect(i).TupleInt().I, hv_column.TupleSelect(i).TupleInt().I);
                    m_hWnd.WriteString(hv_DecodedDataString.TupleSelect(i));
                }
                m_hWnd.DispObj(ho_SymbolXlds);
                HOperatorSet.GenRegionContourXld(ho_SymbolXlds, out ho_SymbolRegion, "filled");
                HOperatorSet.Union1(ho_SymbolRegion, out ho_SymbolRegion);
                HOperatorSet.DilationRectangle1(ho_SymbolRegion, out ho_HRegion, hv_width, 40);
                HOperatorSet.Connection(ho_HRegion, out ho_HRegion);
                HOperatorSet.SortRegion(ho_HRegion, out ho_HSortRegion, "first_point", "true", "row");
                //X方向
                HTuple hv_xCalib = new HTuple();
                for(int i =1; i<= ho_HSortRegion.CountObj(); i++)
                {
                    ho_SymbolXlds.Dispose();
                    hv_ResultHandles = new HTuple();
                    hv_DecodedDataString = new HTuple();
                    HOperatorSet.SelectObj(ho_HSortRegion, out ho_selectObj, i);
                  //  m_hWnd.DispObj(ho_selectObj);
                    HOperatorSet.ReduceDomain(m_hImage, ho_selectObj, out ho_ImgReduced);
                    HOperatorSet.FindDataCode2d(ho_ImgReduced, out ho_SymbolXlds, hv_DataCodeHandle, "stop_after_result_num", 3, out hv_ResultHandles, out hv_DecodedDataString);
                    if (1 >= hv_DecodedDataString.TupleLength())
                        return false;
                    HOperatorSet.TupleNumber(hv_DecodedDataString, out hv_TupleNum);
                    HOperatorSet.AreaCenterXld(ho_SymbolXlds, out hv_area, out hv_row, out hv_column, out hv_pointOrder);
                    HOperatorSet.TupleSortIndex(hv_column, out hv_indices);
                    for(int n=0; n<hv_column.TupleLength()-1;n++)
                    {

                        HOperatorSet.DistancePp(hv_row.TupleSelect(hv_indices[n]), hv_column.TupleSelect(hv_indices[n]),
                                                hv_row.TupleSelect(hv_indices[n + 1]), hv_column.TupleSelect(hv_indices[n + 1]), out hv_dist);
                        HOperatorSet.TupleSplit(hv_DecodedDataString.TupleSelect(hv_indices[n]), ",", out hv_SubString);
                        HOperatorSet.TupleSplit(hv_DecodedDataString.TupleSelect(hv_indices[n+1]), ",", out hv_SubString1);
                        HOperatorSet.TupleNumber(hv_SubString, out hv_SubString);
                        HOperatorSet.TupleNumber(hv_SubString1, out hv_SubString1);
                        HOperatorSet.DistancePp(hv_SubString[0].D, hv_SubString[1].D, hv_SubString1[0].D, hv_SubString1[1].D, out hv_BarCodeDist);
                        hv_xCalib = hv_xCalib.TupleConcat(hv_BarCodeDist / hv_dist);
                    }
                }
                if (1 == ho_HSortRegion.CountObj())
                {
                    calibResult.dXCalib = hv_xCalib.TupleMean().D;
                    calibResult.dYCalib = calibResult.dXCalib;
                    return true;
                }
                //Y方向
                HOperatorSet.DilationRectangle1(ho_SymbolRegion, out ho_VRegion, 40, hv_height);
                HOperatorSet.Connection(ho_VRegion, out ho_VRegion);
                HOperatorSet.SortRegion(ho_VRegion, out ho_VSortRegion, "first_point", "true", "col");
                HTuple hv_yCalib = new HTuple();
                for (int i = 1; i <= ho_VSortRegion.CountObj(); i++)
                {
                    ho_SymbolXlds.Dispose();
                    hv_ResultHandles = new HTuple();
                    hv_DecodedDataString = new HTuple();
                    HOperatorSet.SelectObj(ho_VSortRegion, out ho_selectObj, i);
                   // m_hWnd.DispObj(ho_selectObj);
                    HOperatorSet.ReduceDomain(m_hImage, ho_selectObj, out ho_ImgReduced);
                    HOperatorSet.FindDataCode2d(ho_ImgReduced, out ho_SymbolXlds, hv_DataCodeHandle, "stop_after_result_num", 3, out hv_ResultHandles, out hv_DecodedDataString);
                    if (1 >= hv_DecodedDataString.TupleLength())
                        return false;
                    HOperatorSet.TupleNumber(hv_DecodedDataString, out hv_TupleNum);
                    HOperatorSet.AreaCenterXld(ho_SymbolXlds, out hv_area, out hv_row, out hv_column, out hv_pointOrder);
                    HOperatorSet.TupleSortIndex(hv_row, out hv_indices);
                    for (int n = 0; n < hv_row.TupleLength() - 1; n++)
                    {

                        HOperatorSet.DistancePp(hv_row.TupleSelect(hv_indices[n]), hv_column.TupleSelect(hv_indices[n]),
                                                hv_row.TupleSelect(hv_indices[n + 1]), hv_column.TupleSelect(hv_indices[n + 1]), out hv_dist);
                        HOperatorSet.TupleSplit(hv_DecodedDataString.TupleSelect(hv_indices[n]), ",", out hv_SubString);
                        HOperatorSet.TupleSplit(hv_DecodedDataString.TupleSelect(hv_indices[n+1]), ",", out hv_SubString1);
                        HOperatorSet.TupleNumber(hv_SubString, out hv_SubString);
                        HOperatorSet.TupleNumber(hv_SubString1, out hv_SubString1);
                        HOperatorSet.DistancePp(hv_SubString[0].D, hv_SubString[1].D, hv_SubString1[0].D, hv_SubString1[1].D, out hv_BarCodeDist);
                        hv_yCalib = hv_yCalib.TupleConcat(hv_BarCodeDist / hv_dist);
                    }
                }
                calibResult.dXCalib = hv_xCalib.TupleMean().D;
                calibResult.dYCalib = hv_yCalib.TupleMean().D;
                return true;
                
            }
            catch(HalconException error)
            {
                return false;
            }
            finally
            {
                if(null != ho_SymbolXlds) ho_SymbolXlds.Dispose();
                if(null != ho_SymbolRegion) ho_SymbolRegion.Dispose();
                if(null != ho_HRegion) ho_HRegion.Dispose();
                if(null != ho_HSortRegion) ho_HSortRegion.Dispose();
                if(null != ho_VRegion) ho_VRegion.Dispose();
                if(null != ho_VSortRegion) ho_VSortRegion.Dispose();
                if(null != ho_selectObj) ho_selectObj.Dispose();
                if(null != ho_ReiongInter) ho_ReiongInter.Dispose();
                if(null != ho_ImgReduced) ho_ImgReduced.Dispose();
            }

        }

        public static bool LocateCalib(double[] dCol, double[] dRow, //9 Image Point
                                       double[] dX, double[] dY,     //9 machine point 
                                       double[] homMat2d)
        {
            homMat2d = new double[9] { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
            HTuple hv_Col = new HTuple(), hv_Row = new HTuple(), hv_X = new HTuple(), hv_Y = new HTuple();
            HTuple hv_homMat2d = new HTuple();
            try
            {
                for (int i = 0; i < 9; i++)
                {
                    hv_Col[i] = dCol[i];
                    hv_Row[i] = dRow[i];
                    hv_X[i] = dX[i];
                    hv_Y[i] = dY[i];
                }
                HOperatorSet.VectorToHomMat2d(hv_Col, hv_Row, hv_X, hv_Y, out hv_homMat2d);
                if (hv_homMat2d.TupleLength() != 0)
                {
                    for (int i = 0; i < hv_homMat2d.TupleLength(); i++)
                    {
                        homMat2d[i] = hv_homMat2d[i];
                    }
                }
                return true;
            }
            catch (System.Exception error)
            {
                MessageBox.Show("错误：" + error.ToString());
                return false;
            }
        }
        #endregion
        public static void SetImageSize(int width, int height)
        {
            imageWidth = width;
            imageHeight = height;
        }

        public static void GetImage(byte[] imageData)
        {
            try
            {
                if (imageData == null || imageData.Length < 1)
                    throw new Exception(string.Format("图像数据转换失败！原因：图像数据为空！"));

                if (m_hImage == null)
                    m_hImage = new HObject();

                GCHandle gc = GCHandle.Alloc(imageData, GCHandleType.Pinned);
                IntPtr ptr = gc.AddrOfPinnedObject();

                if (gc.IsAllocated)
                {
                    gc.Free();
                }

                m_hImage.Dispose();
                HOperatorSet.GenImage1(out m_hImage, "byte", imageWidth, imageHeight, ptr);
            }
            catch(Exception ex)
            {
                throw new Exception(ex.Message);
            }
        }
        public static void GetImage(byte[] imageData, HWindowControl hWndCtrl)
        {
            try
            {
                if (imageData == null || imageData.Length < 1)
                    throw new Exception(string.Format("图像数据转换失败！原因：图像数据为空！"));

                if (m_hImage == null)
                    m_hImage = new HObject();

                GCHandle gc = GCHandle.Alloc(imageData, GCHandleType.Pinned);
                IntPtr ptr = gc.AddrOfPinnedObject();

                if (gc.IsAllocated)
                {
                    gc.Free();
                }

                m_hImage.Dispose();
                HOperatorSet.GenImage1(out m_hImage, "byte", imageWidth, imageHeight, ptr);

                double dReslutRow0 = 0, dReslutCol0 = 0, dReslutRow1 = 0, dReslutCol1 = 0;
                FitImageToWindow(hWndCtrl, out dReslutRow0, out dReslutCol0, out dReslutRow1, out dReslutCol1);
                //ShowImages(dReslutRow0, dReslutCol0, dReslutRow1, dReslutCol1);
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message);
            }
        }
 
    }

}



